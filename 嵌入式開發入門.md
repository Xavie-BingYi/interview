# 目錄

1. [嵌入式系統概述](#1-嵌入式系統概述)
2. [什麼是MCU？](#2-什麼是mcu)
3. [的開發板選擇適合與MCU](#3-選擇適合的開發板與mcu)
4. [嵌組入式系統架構與件](#4-嵌入式系統架構與組件)
   1. [MCU的基本結構](#41-mcu的基本結構)
   2. [記憶體架構與暫存器 (Memory Architecture & Registers)](#42-記憶體架構與暫存器-memory-architecture--registers)
   3. [時脈計時與 (Clock & Timers)](#43-時脈與計時-clock--timers)
   4. [中斷系統 (Interrupt System)](#44-中斷系統-interrupt-system)
   5. [GPIO 基本應用 (General Purpose Input/Output)](#45-gpio-基本應用-general-purpose-inputoutput)
   6. [I/O 介面與外部擴展模組 (I/O Interfaces & Peripherals)](#46-io-介面與外部擴展模組-io-interfaces--peripherals)
   7. [電源管理與低功耗模式 (Power Management & Low-Power Modes)](#47-電源管理與低功耗模式-power-management--low-power-modes)
   8. [系統效能優化技術 (System Performance Optimization Techniques)](#48-系統效能優化技術-system-performance-optimization-techniques)
5. [嵌入式韌體與開發](#5-嵌入式韌體與開發)
   1. [韌體設計的基礎原理](#51-韌體設計的基礎原理)
   2. [韌體與硬體的交互](#52-韌體與硬體的交互)
   3. [編譯與交叉編譯概述](#53-編譯與交叉編譯概述)
   4. [中斷管理與例外處理](#54-中斷管理與例外處理)
   5. [記憶體管理策略](#55-記憶體管理策略)
   6. [功能模組化與最佳化](#56-功能模組化與最佳化)
   7. [韌體調試與除錯工具](#57-韌體調試與除錯工具)
   8. [系統效能調校與優化](#58-系統效能調校與優化)
6. [編譯與燒錄韌體](#6-編譯與燒錄韌體)
   1. [STM32 記憶體區域與初始化過程](#61-stm32-記憶體區域與初始化過程)
   2. [燒錄器執行檔的生成與自動化](#62-燒錄器執行檔的生成與自動化)
   3. [交叉編譯器與目標平台的設定](#63-交叉編譯器與目標平台的設定)
   4. [編譯與燒錄流程概述](#64-編譯與燒錄流程概述)
   5. [Makefile 概述與編譯過程管理](#65-makefile-概述與編譯過程管理)
   6. [Makefile 範例與實際應用](#66-makefile-範例與實際應用)
7. [STM32 MCU的啟動與執行](#7-stm32-mcu的啟動與執行)
   1. [固定記憶體映射與程式燒錄儲存位置](#71-固定記憶體映射與程式燒錄儲存位置)
   2. [程式燒錄與開機配置](#72-程式燒錄與開機配置)
   3. [Linker Script 與 STM32 記憶體配置](#73-linker-script-與-STM32-記憶體配置)


   3. [STM32開機過程中的記憶體映射配置](#73-stm32-開機過程中的記憶體映射配置)
   4. [MCU的開機流程](#74-mcu的開機流程)
   5. [Flash記憶體與啟動過程](#75-flash-記憶體與啟動過程)
   6. [Bootloader的運作與配置](#76-bootloader的運作與配置)
8. [嵌入式系統調試與優化](#8-嵌入式系統調試與優化)
9. [實際案例與專案開發](#9-實際案例與專案開發)
--------------------------------------------------
# 1. 嵌入式系統概述


--------------------------------------------------
# 2. 什麼是MCU？


--------------------------------------------------
# 3. 選擇適合的開發板與MCU

選擇適合的開發板和 MCU 是一項對於嵌入式系統開發至關重要的任務，特別是當目標是以最低成本完成專案時。理解選擇過程的要點可以幫助你做出更有智慧的決策。以下是一些步驟與考量因素，幫助你選擇適合的開發板與 MCU。

## 1. 確認專案功能需求

首先，評估你的專案需求。這可以幫助你選擇最合適的 MCU。

- **運算能力**：確定你需要的計算速度。如果專案需要大量數據處理或即時控制，可能需要選擇時脈頻率較高的 MCU。一般而言，時脈頻率越高，處理速度越快。例如，對於需要處理數位信號處理 (DSP) 或複雜數學運算的應用，可能會選擇有浮點運算單元 (FPU) 的 MCU。

- **記憶體需求**：每個 MCU 都有不同大小的 Flash 和 SRAM。確保選擇的 MCU 記憶體大小能夠容納你的程式碼和需要的數據。例如，STM32F4 系列 MCU 擁有較大的 Flash 和 SRAM，適合複雜的應用，而較小型的 MCU 則適合簡單的控制系統。

- **外設支援**：根據你的專案需求，檢查 MCU 是否支援所需的通訊協定和外設。例如，I2C、SPI、UART、PWM 等常見外設，這些在多數 MCU 上都有，但每個 MCU 的數量和性能可能有所不同。

## 2. 開發環境與工具支持

選擇一個方便的開發環境對新手非常重要。不同的 MCU 開發板支持不同的開發工具。

- **開發工具**：確保所選擇的開發板有良好的開發環境支持。以 STM32 為例，它提供 STM32CubeMX 和 STM32CubeIDE，這些工具可以幫助你快速配置硬體、生成初始化代碼以及進行除錯。對於 Arduino，也有非常廣泛的支援社群和簡單易用的開發工具。

- **編譯器支援**：目前大多數 MCU 開發板都支持 GCC 編譯器。這對於不想依賴專有編譯器的新手來說，無疑是個加分項。STM32、Arduino 等都支持 GCC，使得你可以輕鬆地進行跨平台開發。

## 3. 評估開發板的差異與選擇

每個開發板都有其獨特的優勢。這裡列出一些常見的開發板，幫助你做出選擇：

- **STM32**：STM32 是一個廣泛使用的微控制器平台，擁有多樣化的產品線，從低功耗型到高性能型的 MCU 都有。STM32 具有豐富的外設選擇，並且廣泛支持開發工具如 STM32CubeMX、CubeIDE 等，適合中高級的嵌入式開發。

- **Arduino**：對於初學者來說，Arduino 是一個非常受歡迎的選擇。Arduino 開發板價格便宜，並且有大量的庫和範例代碼，可以幫助你快速上手。它通常使用 ATmega 系列 MCU，並且支援簡單的編程環境，非常適合入門學習。

- **TI (Texas Instruments)**：TI 提供的開發板，如 MSP430、Tiva C 系列，通常具有較低功耗和較高的性價比，適合需要低功耗運行的應用。TI MCU 也支持 GCC 編譯器，可以與許多開發環境一起使用。

- **Microchip (以前的 Atmel)**：Microchip 的 PIC 和 SAM 系列 MCU 也常用於嵌入式系統中。這些 MCU 有時會提供更高的性能和更多的外設選項，但開發環境可能比 STM32 或 Arduino 複雜。

## 4. 計算性能需求與性價比考量

選擇開發板時，需要考慮你的應用對性能的需求。

- **時脈頻率**：如果你的專案需要進行即時處理或高速計算，則時脈頻率至關重要。不同 MCU 的時脈頻率範圍可以從幾十 MHz 到上百 MHz。對於簡單的控制系統，較低頻率的 MCU 可能就夠用了，但如果是需要高速數據處理或運算的專案，你需要選擇性能更強的 MCU。

- **計算成本效益比**：考慮 MCU 的性能和成本之間的平衡。STM32 和 Arduino 之間，STM32 提供更多的選擇，並且性價比高。而 Arduino 在簡單的控制系統中也能夠發揮作用，且價格低廉。你需要根據你的需求選擇最適合的 MCU，避免過度設計。

--------------------------------------------------
# 4. 嵌入式系統架構與組件

嵌入式系統的架構涉及許多不同的組件和模組，每一個模組都在系統的運行中扮演著關鍵角色。理解這些組件的功能和它們之間的相互作用，對於設計和開發嵌入式系統至關重要。以下是嵌入式系統架構中主要組件的介紹，並探索它們之間的關聯性。

## 4.1 MCU的基本結構

### 核心組件
介紹 MCU（微控制器單元）的基本組件，這些組件共同協作來實現嵌入式系統的功能。

1. **CPU（中央處理單元）**  
   - 負責執行指令並進行計算。  
   - 控制其他組件的運作，確保系統功能的正常運行。

2. **記憶體**  
   - 包括兩種主要記憶體：  
     - **Flash 記憶體**：儲存程式碼，執行啟動和控制程序。  
     - **SRAM（靜態隨機存取記憶體）**：儲存運行時的數據和變數。  
   - 記憶體配置與管理對於系統效能至關重要。

3. **計時器（Timers）**  
   - 提供計時和時間控制功能，常用於延遲、計時事件和 PWM（脈衝寬度調變）控制等。

4. **ADC（類比數位轉換器）**  
   - 將來自外部設備（如感測器）的類比訊號轉換為數位數據，供處理器使用。

5. **數位輸入/輸出（GPIO）**  
   - 用於與外部設備進行控制和通信。常見的應用包括控制LED、馬達或讀取開關狀態。

### MCU基本結構概述
MCU是嵌入式系統的核心，主要由處理器（CPU）、記憶體（Flash和SRAM）以及I/O介面等組成。這些組件相互依賴並協同工作，確保嵌入式系統的功能和性能：

- **CPU**：負責程式執行和數據處理。
- **記憶體**：儲存程式和資料，影響系統的運行效率。
- **I/O介面**：使MCU能與外部設備（如感測器、顯示屏等）進行數據交換。

### 與其他章節的關聯
- 了解MCU的基本結構後，可以進一步深入研究每個組件的詳細功能，並探索如何設計與外部設備的交互系統。例如，**記憶體架構**將解釋如何有效管理不同類型的記憶體，**I/O介面**則描述如何選擇適當的通信協定來與外部硬體進行數據交換。
- 掌握這些基礎知識，將有助於設計高效能且穩定的嵌入式系統。

## 4.2 記憶體架構與暫存器 (Memory Architecture & Registers)

### 記憶體分佈
MCU的記憶體結構對於系統的運行效率至關重要，主要包括以下區域：
- **程式區（Flash）**：儲存MCU執行的程式碼。這些指令在MCU啟動時會被加載並執行，通常為非易失性記憶體。
- **資料區（RAM）**：用來儲存運行時的變量和中間計算結果。資料區屬於易失性記憶體，當MCU斷電時資料會丟失。
- **堆疊區**：用於儲存函式調用和局部變量。堆疊區的操作是線性進行的，通常與程式執行過程中的呼叫和返回有關。

### 暫存器的角色
暫存器是CPU內部的一種高速記憶體，用來存儲運算過程中的臨時數據。暫存器的主要特點：
- **高速存取**：相較於RAM，暫存器提供更快的數據讀寫速度。
- **控制與配置**：MCU的各種功能和外設（如計時器、GPIO等）通過暫存器進行控制和配置，這些暫存器是程序與硬體之間的橋樑。

### 資料操作
程式可以通過對暫存器進行讀寫來實現資料操作。這些操作涉及到以下幾個步驟：
1. **讀取暫存器**：將暫存器中的數據讀取到處理器內部。
2. **寫入暫存器**：將數據寫入暫存器，進而控制硬體或進行其他操作。
3. **暫存器操作示例**：例如，通過設定GPIO暫存器來控制外部LED的開關，或透過計時器暫存器設置計時器的時間。

### 記憶體與暫存器的關聯性
- 記憶體與暫存器之間的協作確保了系統能夠高效運行。MCU的程式區（Flash）儲存著執行程式，而資料區（RAM）則用來儲存運行時需要的數據。暫存器則加速了運算過程中的臨時數據處理。
- 這些組件相互協作，使MCU能夠高效地處理數據並實現預期的功能。

### 與其他章節的關聯
- 了解記憶體架構和暫存器的運作後，可以進一步深入設置 **外部設備**（如GPIO、計時器等）和 **時脈管理**。暫存器的操作和配置對外部硬體控制至關重要。
- 記憶體管理技巧也有助於在進行 **電源管理** 和 **效能優化** 時合理配置系統資源，確保系統在不同運行模式下達到最佳效能。

## 4.3 時脈與計時 (Clock & Timers)

### 時脈來源與配置
MCU的運行依賴於時脈來協調各個模組的運作。時脈源可以分為以下兩種類型：
- **內部時脈**：MCU內建的時脈源，通常用於一般應用。這些時脈源不需要外部硬體支持，適合對精度要求不高的應用。
- **外部時脈**：外部提供的時脈源，具有更高的準確度和穩定性。這類時脈源適合於對精密度要求較高的應用，如通訊或高精度測量。

時脈的配置方式會直接影響到MCU的執行速度與外設的協同工作。通常，MCU會根據應用需求選擇內部或外部時脈，並可進行時脈源切換和配置以調整運行頻率。

### 計時器的基本功能
計時器是與時脈系統密切相關的外部模組，用來處理時間計量、週期性任務或事件驅動的行為。計時器的基本功能包括：
- **計時**：計時器用來精確計量時間，通常以時脈為基準，能夠精確地控制時間流逝。
- **週期性任務**：計時器可用來定時執行週期性任務，這對於需要準確控制時間間隔的應用非常重要。
- **事件驅動**：計時器可以根據指定的時間間隔觸發事件，這些事件可用來控制其他硬體或啟動中斷。

### 應用實例
計時器在嵌入式系統中的應用非常廣泛，以下是一些常見的應用示例：
- **LED閃爍**：利用計時器產生固定的時間間隔來控制LED燈的開關，實現LED的閃爍效果。
- **PWM控制**：計時器用來生成精確的PWM波形，這對於馬達速度控制、亮度調節等應用至關重要。

透過計時器，MCU能夠實現精確的時間控制，並確保即時應用的順利運行。

### 與其他章節的關聯
- **外部設備控制**：計時器可用來控制外部硬體設備，如使用PWM控制馬達或其他外部模組。
- **中斷系統**：計時器可以產生中斷，進而觸發中斷服務程序，影響中斷系統的工作原理。
- **效能優化**：時脈配置與計時器的精確度影響系統的效能優化。合理的時脈與計時器設置能夠提升系統的精度和響應速度。

## 4.4 中斷系統 (Interrupt System)

### 中斷概念
中斷是一種讓MCU能夠在必要時快速響應特定事件的機制。當特定事件（如外部信號或內部狀態變更）發生時，中斷系統會中斷當前的程序執行，並轉向執行預定的中斷服務例程（ISR）。這種機制能夠保證即時性高的事件被及時處理，而不需要MCU不斷輪詢事件狀態。

### 中斷優先權
中斷優先權決定了不同中斷事件的處理順序。在系統中，某些中斷可能比其他中斷更為緊急，這時需要設定優先權：
- **高優先權中斷**：當高優先權中斷發生時，會立即中斷低優先權的中斷處理。
- **低優先權中斷**：這些中斷只有在所有高優先權中斷處理完成後才會被執行。

在許多MCU中，這些優先權是可配置的，通過設置中斷控制寄存器來確定各中斷源的優先級。

### 應用案例
中斷系統廣泛應用於各種嵌入式系統中，以下是一些常見的應用：
- **按鍵中斷**：當按鍵被按下時，可以通過中斷來即時處理按鍵事件，避免輪詢方式的效率低下。
- **計時器中斷**：計時器中斷可用於周期性任務執行，如定時觸發某些功能，或定時監控系統狀態。

這些應用使得MCU能夠快速響應外部事件，並有效管理時間關鍵的操作。

### 與其他章節的關聯
- **記憶體架構**：中斷服務例程通常需要存取暫存器來臨時存儲中斷數據。理解記憶體架構有助於設計高效的中斷處理機制。
- **I/O介面**：中斷經常用於處理來自外部設備的事件，因此理解I/O介面和外設如何觸發中斷是設計有效中斷系統的關鍵。

## 4.5 GPIO 基本應用 (General Purpose Input/Output)

GPIO（通用輸入輸出）是嵌入式系統中非常常見的一種 I/O 介面，主要用於與外部設備進行基本的數位信號交換。這些引腳可以配置為輸入或輸出，並用來控制LED、開關、感測器等外部設備。

### GPIO 基本應用
- 介紹如何透過 GPIO 控制 LED、開關等外部設備。
- **外部設備控制**：如馬達、感測器等的連接和控制方法。
- **擴展實例**：展示 GPIO 控制的基本步驟。

### GPIO 應用範例：
- **控制 LED**：通過設置 GPIO 輸出高低電位來控制 LED 開關。
- **讀取開關狀態**：將 GPIO 設置為輸入，從開關或按鈕讀取狀態。
- **PWM 輸出**：利用 GPIO 輸出 PWM 信號來調節馬達速度或 LED 亮度。

這些應用展示了 GPIO 在嵌入式系統中的基本操作，並為開發者提供了簡單易用的控制接口。

### 與其他章節的關聯
了解 GPIO 基本應用後，你可以進一步學習如何設置更複雜的 I/O 介面，並使用 GPIO 控制外部設備（如傳感器和馬達）。

## 4.6 I/O 介面與外部擴展模組 (I/O Interfaces & Peripherals)

I/O 介面是嵌入式系統中與外部設備交換數據的關鍵。這些介面提供了與外部硬體溝通的通道，並根據不同需求選擇相應的通訊協定。外部擴展模組則為系統提供更多功能，如類比信號處理、高速數據傳輸等。

### 常見的 I/O 介面
- **UART (Universal Asynchronous Receiver/Transmitter)**：點對點串列通訊，適用於簡單的數據傳輸。
- **I2C (Inter-Integrated Circuit)**：適用於短距離、多設備通訊，常用於感測器和其他外部模組。
- **SPI (Serial Peripheral Interface)**：高速的全雙工通訊協定，適合需要高速數據交換的應用。

### 外部擴展模組
- **ADC (Analog-to-Digital Converter)**：將類比信號轉換為數位信號，通常用於處理來自感測器的數據。
- **DAC (Digital-to-Analog Converter)**：將數位信號轉換為類比信號，應用於音頻或顯示控制。
- **PWM (Pulse Width Modulation)**：用於控制電壓或電流輸出的脈衝寬度調變技術，常見於馬達控制或 LED 亮度調節。

這些 I/O 介面與外部擴展模組能夠與 MCU 的核心部件協作，擴展嵌入式系統的功能，並提升其對外部設備的控制能力。

### 與其他章節的關聯
了解 I/O 介面與外部擴展模組後，開發者能夠選擇合適的通訊協定來控制外部設備，並學會如何配置這些模組以提高系統性能。例如，學會如何設置 ADC 和 PWM 模組後，你會了解它們如何與 GPIO 配合使用來實現更多複雜功能。

## 4.7 電源管理與低功耗模式 (Power Management & Low-Power Modes)

- **電源管理**：說明嵌入式系統如何通過電源管理延長運行時間。
- **低功耗模式**：解釋 MCU 的不同低功耗模式，如睡眠模式、停機模式。
- **低功耗應用**：介紹節能設計的實用性，如 IoT 裝置的應用。

在嵌入式系統中，尤其是便攜式設備，電源管理是設計的關鍵。MCU通常提供多種低功耗模式，以延長電池壽命並降低系統的功耗。常見的電源管理模式包括：

- **睡眠模式**：系統將部分模組關閉，保留最基本的功能。
- **停止模式**：幾乎所有模組關閉，只保留關鍵功能，進一步降低功耗。
- **待機模式**：最低功耗狀態，通常只有RAM保持活動，並能在外部事件觸發下快速恢復。

良好的電源管理可以在保持系統效能的同時，大幅提高能效，這對於需要長時間運行的嵌入式設備至關重要。

### 與其他章節的關聯
電源管理與多個章節有密切關聯。例如，它與 **記憶體架構** 有關，因為需要管理不同類型的記憶體的功耗（例如RAM與Flash的差異）。同時，涉及到 **時脈系統** 和 **外部擴展**，因為控制這些外部設備的開關有助於節省功耗。此外，學會電源管理後，會讓你在 **效能優化** 和 **中斷系統** 設計時做出更好的平衡，特別是在處理需要高效能的應用場景時。

## 4.8 系統效能優化技術 (System Performance Optimization Techniques)

在資源受限的嵌入式系統中，效能優化技術是提升系統效率和性能的關鍵。以下是幾種常見的效能優化方法：

- **Harvard架構**：將指令和資料存儲分開，從而提高存取速度，提升處理效能。
- **硬體加速單元**：例如浮點運算單元（FPU）和快速乘法器，這些硬體功能可以加速數學運算，提高處理速度。
- **記憶體配置優化**：有效使用暫存器、快取等，減少內存訪問延遲，從而提高運算效率。

### Cortex-M4處理器架構與效能優化

**Cortex-M4** 處理器採用了 **Harvard 架構**，這意味著程式碼和資料分別通過兩個獨立的匯流排來存取。具體來說，處理器有以下兩個匯流排：

- **指令匯流排（Instruction Bus）**：用來存取程式碼。
- **資料匯流排（Data Bus）**：用來存取運行中的資料。

這樣的設計允許處理器同時進行指令的讀取和資料的存取，這不僅提升了處理效率，還減少了處理器等待時間，從而顯著提高了效能。

### 處理器性硬體加速特

Cortex-M4 處理器內建了數個硬體加速單元，這些加速單元能顯著提升數據處理速度，尤其是在進行數學計算和數字信號處理（DSP）任務時。以下是幾個關鍵的硬體加速特性：

- **單週期乘法器（Single-Cycle Multiply）**：這個加速單元能在單個時鐘週期內完成乘法運算，大幅提升了數學計算的效率，尤其對於大量乘法運算的應用非常有用。
- **單週期乘加運算器（Single-Cycle MAC）**：此加速單元結合了乘法與加法運算，能在單個時鐘週期內同時完成。這對於數字信號處理（如濾波器運算）尤其有利，能有效提升處理速度。
- **浮點運算單元（FPU）**：Cortex-M4 處理器內建的浮點運算單元支持單精度浮點數運算，符合 IEEE 754 標準。這使得處理器在進行浮點數計算時，比起純粹依賴軟體運算的情況，能顯著提升效能，特別適用於控制系統、信號處理和其他需要精確浮點數計算的應用。

這些硬體加速特性使 Cortex-M4 處理器能夠更高效地執行複雜的數學運算，尤其是在需要高效數據處理的應用中，如音頻處理、控制系統和信號處理。內建的浮點運算單元進一步擴展了其應用範圍，特別是在要求高精度計算的場景中，提供了顯著的運算性能提升。

### 優化效能

Cortex-M4 的 **Harvard 架構** 和 **獨立的指令與資料匯流排** 設計，實現了指令和資料訪問的平行處理，避免了存取衝突，進一步優化了系統效能。這種設計使處理器在讀取程式碼的同時能夠高效地存取資料，尤其適合複雜計算和多任務處理。搭配其內建的硬體加速運算單元，Cortex-M4 在進行數學運算、數字信號處理、以及高速運算等應用時，展現出極高的效能，使得 STM32F4 微控制器在這些領域中具有顯著的競爭優勢。

--------------------------------------------------
# 5. 嵌入式韌體與開發

## 5.1 韌體設計的基礎原理
- **韌體的角色**：介紹韌體在嵌入式系統中的核心角色，負責控制硬體並實現特定功能。
- **設計原則**：簡述韌體設計中需要遵守的基本原則，如高效、可維護性與可擴展性。
- **開發流程**：介紹韌體開發的基本流程，包括需求分析、設計、實現與測試。

## 5.2 韌體與硬體的交互
- **硬體抽象層 (HAL)**：介紹硬體抽象層如何幫助韌體與硬體進行交互，提供簡單的介面來控制硬體。
- **韌體控制硬體**：展示如何利用韌體來控制 MCU 上的外部硬體元件（如 GPIO、ADC、PWM 等）。
- **中斷處理**：解釋韌體如何處理外部事件，特別是如何響應中斷。

## 5.3 編譯與交叉編譯概述
- **編譯過程**：介紹編譯韌體時所涉及的過程，從源代碼到可執行文件的轉換。
- **交叉編譯器**：解釋交叉編譯的概念，即在一個平台上編譯為另一個平台生成程式碼，特別是針對 MCU 平台。
- **編譯工具鏈**：介紹常用的嵌入式編譯工具鏈，例如 GCC 和 ARM Keil。

## 5.4 中斷管理與例外處理
- **中斷處理機制**：介紹 MCU 如何處理中斷，包括中斷向量表和優先級設置。
- **例外處理**：解釋 MCU 在異常情況下如何處理錯誤，例如硬體故障或運行時錯誤。
- **中斷服務程式 (ISR)**：展示如何編寫中斷服務程式來處理特定事件。

## 5.5 記憶體管理策略
- **靜態與動態記憶體分配**：介紹靜態記憶體分配（如全域變數）和動態記憶體分配（如堆積區）。
- **記憶體區域的劃分**：解釋堆疊區、堆積區與全域區的區別與用途。
- **記憶體保護**：介紹如何利用 MCU 的硬體特性來保護記憶體區域，防止非法訪問。

## 5.6 功能模組化與最佳化
- **模組化設計**：介紹如何將韌體分解為若干功能模組，以便於開發與維護。
- **最佳化策略**：展示如何進行性能最佳化，包括程式碼優化和記憶體使用最佳化。
- **效能分析工具**：介紹用於分析和優化韌體效能的工具，例如嵌入式調試器。

## 5.7 韌體調試與除錯工具
- **調試工具**：介紹常用的調試工具，如 JTAG、SWD 等，用於韌體開發過程中的除錯。
- **除錯策略**：解釋常見的除錯策略，如單步執行、變數觀察與斷點設置。
- **錯誤檢測與修正**：介紹如何利用工具定位並修正程式中的錯誤，確保韌體的穩定性。

## 5.8 系統效能調校與優化
- **效能瓶頸分析**：介紹如何識別系統中的效能瓶頸，例如計算、記憶體或I/O操作。
- **最佳化技術**：展示如何使用硬體加速、低功耗設計等技術來提升系統效能。
- **功耗管理**：解釋如何優化系統的功耗，特別是針對低功耗應用場景（如 IoT 裝置）。

--------------------------------------------------
# 6. 編譯與燒錄韌體

## 6.1 STM32 記憶體區域與初始化過程

在 STM32 微控制器中，程式碼和資料被劃分為不同的記憶體段，這些段在執行時會映射到 Flash 記憶體和 SRAM 中。這些記憶體段的配置由 **Linker Script**（連結腳本）控制，並且能夠確保 STM32 在啟動後正確地初始化並執行程式碼。

### Linker 決定段的分配位置

在 STM32F4 中，通常會有以下幾個重要的段：

- **`.text` 段**：這個段包含程式碼，它通常存放在 Flash 記憶體中。這樣設計的目的是確保程式碼能夠在斷電後保持不變，並且在 MCU 開機後可以從 Flash 記憶體中執行。
  
- **`.data` 段**：這個段包含已初始化的全域變數。在程式啟動時，這些變數的初始值會從 Flash 記憶體複製到 SRAM 中，以便程式運行時使用。
  
- **`.bss` 段**：這個段包含未初始化的全域變數。這些變數的初始值會被設為零，並且它們會直接配置在 SRAM 中，無需在程式啟動時從 Flash 中複製。

### 記憶體段的配置

- **程式碼段 `.text`** 儲存在 Flash 記憶體中，確保每次上電時程式能夠被執行。
- **資料段 `.data` 和 `.bss`** 儲存在 SRAM 中，確保程式在運行時能夠快速訪問和修改變數。

這些記憶體段的分配和初始化過程由 **Linker Script** 決定，這個腳本會指示哪些段應該放在哪個區域，並且會設置適當的啟動過程來初始化 SRAM 和 Flash 中的資料。

## 6.2 燒錄器執行檔的生成與自動化

在嵌入式系統開發中，生成燒錄檔案並將其燒錄到硬體上是重要的工作流程。手動生成燒錄檔案雖然可行，但隨著專案複雜度的增加，手動編譯、組譯及燒錄的過程將變得繁瑣且耗時。為了提高開發效率，可以利用自動化工具如 `Makefile` 來簡化這一過程。

### 手動生成燒錄檔案
手動生成燒錄檔案的過程通常包含以下步驟：
1. 使用交叉編譯器（如 `arm-none-eabi-gcc`）編譯源碼，生成中間檔案（如 `.o` 檔案）。
2. 將這些中間檔案進行組合、連結，最終生成 `.elf` 或 `.bin` 格式的燒錄檔。
3. 使用燒錄工具（如 `st-flash`、`JLink` 或 `OpenOCD`）將生成的燒錄檔案燒錄到目標嵌入式硬體。

例如，透過 `st-flash` 工具來將 `.bin` 檔案燒錄到 STM32 開發板：
```bash
st-flash write program.bin 0x8000000
```
其中 `0x8000000` 是 STM32 Flash 記憶體的起始地址。

### 使用 Makefile 自動化流程

手動進行這些步驟可能會浪費大量時間，特別是在處理較大的專案時。利用 Makefile 可以自動化編譯和燒錄過程，通過簡單的指令來管理整個流程。

### 以下是利用 Makefile 自動化生成燒錄檔案的範例：

1. **設定交叉編譯器和編譯選項**：  
   在 Makefile 中，首先設定交叉編譯器（如 `arm-none-eabi-gcc`）和編譯選項（如目標平台、指令集等）。

```makefile
CC := arm-none-eabi-gcc
CFLAGS := -mcpu=cortex-m3 -mthumb -O0 -gdwarf-2 -g3
```
2. **編譯和連結規則**：  
   定義編譯源碼的規則，將源檔案（如 `.c` 和 `.S` 檔案）編譯成 `.o` 檔案，並最終連結成 `.elf` 檔案。

```makefile
$(TARGET).elf: $(C_SOURCE)
    $(CC) $(CFLAGS) -o $(TARGET).elf $^
```
3. **轉換為燒錄檔案**：  
   使用 `objcopy` 將 `.elf` 檔案轉換為 `.bin` 檔案，方便燒錄。

```makefile
$(TARGET).bin: $(TARGET).elf
    arm-none-eabi-objcopy -Obinary $(TARGET).elf $(TARGET).bin
```
4. **燒錄檔案到硬體**：  
   利用燒錄工具（如 `st-flash`）將 `.bin` 檔案燒錄到嵌入式設備。

```makefile
flash: $(TARGET).bin
    st-flash write $(TARGET).bin 0x8000000
```
## 優點

1. **自動化過程**：  
   Makefile 使得編譯、連結和燒錄過程自動化，只需執行 `make` 指令即可完成整個流程。

2. **減少錯誤**：  
   避免手動處理繁瑣的編譯和燒錄命令，減少人為錯誤的風險。

3. **提升效率**：  
   使用增量編譯（只編譯修改過的檔案）來大幅提升編譯效率，特別是在大型專案中尤為重要。

## 6.3 交叉編譯器與目標平台的設定

在開發嵌入式系統時，通常開發環境（例如 x86 架構的電腦）與目標硬體平台（例如 ARM 架構的 STM32 微控制器）不同。因此，我們需要使用**交叉編譯器**來生成能夠在目標硬體上執行的程式碼。

### 什麼是交叉編譯器？
交叉編譯器是一種能夠在一種硬體架構上運行並生成另一種硬體架構可執行的程式碼的編譯器。例如，開發者在 x86 架構的電腦上運行編譯器，並生成可以在 ARM 處理器（如 STM32 微控制器）上運行的機器碼。

### 常見的交叉編譯器
- **arm-none-eabi-gcc**：這是針對 ARM 微控制器（如 STM32）的一個交叉編譯器，通常用於裸機（無作業系統）開發。
- **msp430-gcc**：針對 TI MSP430 微控制器的交叉編譯器。
- **avr-gcc**：用於 Atmel AVR 系列微控制器的交叉編譯器。

### 交叉編譯器的工作原理
交叉編譯器的基本工作流程包括以下幾個步驟：
1. **預處理（Preprocessing）**：處理程式碼中的巨集、引入的標頭檔案等。
2. **編譯（Compilation）**：將源程式（如 C 語言）轉換為中間的組合語言（assembly code）。
3. **組譯（Assembly）**：將組合語言轉換為目標平台的機器碼（通常是 `.o` 檔案）。
4. **連結（Linking）**：將多個目標檔案（`.o`）連結成最終的可執行檔案（如 `.elf` 或 `.bin`）。

### 如何指定目標平台的 CPU 型號與參數
交叉編譯器需要知道目標硬體的架構細節，以便生成適當的機器碼。這些資訊通常透過編譯選項來設置。常見的選項包括：
- `-mcpu=cortex-m4`：指定目標處理器為 ARM Cortex-M4，這會告訴編譯器生成適合該處理器的指令碼。
- `-mthumb`：啟用 ARM 的 Thumb 指令集。這種指令集使用較小的指令，適合嵌入式系統，能有效節省程式碼空間。

例如，針對 STM32F429 開發板（基於 ARM Cortex-M4 核心），你可以使用以下命令來編譯程式：
```bash
arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -o program.elf main.c
```
這樣的命令會將 `main.c` 編譯為適用於 STM32F429 的 `.elf` 檔案。

### 轉換為二進位檔案（可選）

有時候，我們需要將 `.elf` 檔案轉換為 `.bin` 格式，這樣才能通過燒錄工具將程式燒錄到目標硬體中。你可以使用以下命令進行轉換：

```bash
arm-none-eabi-objcopy -O binary program.elf program.bin
```
這條命令將 `program.elf` 轉換為純二進位格式的 `program.bin`。

### 使用燒錄工具燒錄檔案

將編譯和轉換後的檔案燒錄到目標硬體中。常見的燒錄工具有：

- **ST-Link**：STM32 系列開發板的專用燒錄器，常與 STM32CubeIDE 配合使用。
- **J-Link**：另一款常見的燒錄器，支持多種微控制器，通常用於更高效的開發過程。

例如，使用 `st-flash` 可以將 `.bin` 檔案燒錄到 STM32 開發板：

```bash
st-flash write program.bin 0x8000000
```
這裡 `0x8000000` 是 STM32 開發板 Flash 記憶體的起始地址。

### 補充：STM32CubeIDE 和燒錄工具

在 STM32 的開發過程中，**STM32CubeIDE** 是一個常用的開發工具，它內建了 ST-Link 支持，用來直接將編譯好的程式燒錄到 STM32 開發板上。這樣，開發者不需要手動使用燒錄工具，IDE 會自動處理編譯、燒錄的過程。

## 6.4 編譯與燒錄流程概述

在嵌入式系統開發中，編譯與燒錄的流程通常包含以下幾個步驟：

### 1. 編寫程式碼
開發者首先在主機上編寫 C 程式碼（如 `main.c`），並將其保存為 `.c` 檔案。

### 2. 使用交叉編譯器進行編譯
為了能夠在目標硬體上運行程式，必須使用交叉編譯器來編譯源碼。交叉編譯器（如 `arm-none-eabi-gcc`）能夠生成適用於特定處理器（如 STM32 系列的 ARM Cortex-M 核心）的可執行檔案。例如，編譯指令如下：
```bash
arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb -o program.elf main.c
```
此命令會將 `main.c` 編譯為 STM32F429 開發板上運行的 `.elf` 文件。

### 3. 轉換為 .bin 格式（可選）

有時候，需要將 `.elf` 檔案轉換為 `.bin` 格式，這是純二進位檔案格式，適合燒錄到目標設備中。轉換指令如下：

```bash
arm-none-eabi-objcopy -O binary program.elf program.bin
```
### 4. 使用燒錄工具燒錄韌體

將生成的 `.bin` 或 `.elf` 檔案燒錄到目標開發板（如 STM32F429）上。常見的燒錄工具有 `st-flash`、`JLink` 和 `OpenOCD`。例如，使用 `st-flash` 可以使用以下指令：

```bash
st-flash write program.bin 0x8000000
```
這條命令將 `.bin` 檔案寫入 STM32F429 開發板的 Flash 記憶體，`0x8000000` 是 STM32 的記憶體起始地址。

## 6.5 Makefile 概述與編譯過程管理

在嵌入式系統的開發過程中，專案通常會包含多個源碼文件。手動編譯和管理這些檔案變得十分繁瑣，這時使用 `Makefile` 可以大大簡化編譯過程。`Makefile` 是一個專門用來自動化編譯過程的文件，通常搭配 `make` 工具來使用。

### 1. Makefile 是什麼？
`Makefile` 是用來定義如何編譯和鏈接程序的腳本文件，它包括以下主要元素：

- **目標 (targets)**：指定要生成的檔案或要執行的操作。
- **依賴 (dependencies)**：描述目標檔案所依賴的其他檔案。
- **規則 (rules)**：定義如何從依賴檔案生成目標檔案的具體操作指令。

### 2. Makefile 的功能與作用
`Makefile` 的核心作用是自動化繁瑣的編譯過程，特別是在多檔案的專案中。它能夠：

- **自動化編譯**：只需要執行 `make`，Makefile 就會根據定義的規則自動進行編譯。
- **增量編譯**：`Makefile` 會檢查哪些檔案被修改過，只編譯改動的部分，避免每次都重新編譯整個專案，提高編譯效率。
- **多檔案管理**：當專案中有多個源碼文件時，`Makefile` 會自動處理它們的依賴關係，確保正確的編譯順序。

### 3. Makefile 與 C 語言編譯流程的關聯
C 語言的編譯過程通常包括四個階段：

1. **預處理 (Pre-processing)**：處理巨集、引入標頭檔案等。
2. **編譯 (Compilation)**：將 C 原始碼轉換為中間的組合語言。
3. **組譯 (Assembly)**：將組合語言轉換為目標機器碼（`.o` 檔）。
4. **連結 (Linking)**：將多個目標檔案（`.o` 檔案）合併為最終的可執行檔案（`.elf` 或 `.bin`）。

`Makefile` 主要用來自動化上述過程，根據規則進行編譯、組譯、連結等操作。開發者只需定義好編譯指令，`make` 就會依次完成這些步驟。

### 4. Makefile 的結構
一個簡單的 `Makefile` 範例：
```makefile
CC = gcc
CFLAGS = -Wall -O2
OBJ = main.o util.o
TARGET = program

all: $(TARGET)

$(TARGET): $(OBJ)
	$(CC) $(OBJ) -o $(TARGET)

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -f $(OBJ) $(TARGET)
```
- **變數定義**：用來定義編譯器（`CC`）、編譯選項（`CFLAGS`）、目標檔案（`TARGET`）等。
- **目標與依賴**：定義最終目標（`program`）和其依賴的 `.o` 檔案（`main.o` 和 `util.o`）。
- **編譯規則**：指定如何從 `.c` 檔案生成 `.o` 檔案，並如何將所有 `.o` 檔案連結為最終的可執行檔案。
- **清理規則**：用於刪除編譯過程中生成的中間檔案，保持專案乾淨。

### 5. Makefile 的優點

1. **簡化編譯過程**：  
   Makefile 可以自動執行編譯、組譯、連結等步驟，開發者無需手動輸入繁瑣的命令。

2. **提高編譯效率**：  
   Makefile 只會重新編譯那些有變更的檔案，避免了不必要的重複編譯，從而提高效率。

3. **統一編譯流程**：  
   專案成員可以使用相同的 Makefile，確保編譯過程的一致性，避免因為手動操作而引發錯誤。

## 6.6 Makefile 範例與實際應用

在嵌入式系統開發中，使用 Makefile 可以極大地簡化編譯和燒錄流程。這裡將展示如何通過 Makefile 來管理交叉編譯工具、編譯源碼並生成燒錄檔案。

### 1. 定義交叉編譯工具與變數

```makefile
CROSS_COMPILE ?= arm-none-eabi-
CC := $(CROSS_COMPILE)gcc
AS := $(CROSS_COMPILE)as
CFLAGS = -fno-common -ffreestanding -O0 \
         -gdwarf-2 -g3 -Wall -Werror \
         -mcpu=cortex-m3 -mthumb \
         -Wl,-Tos.ld -nostartfiles
```
這些變數設定了交叉編譯器的前綴和相關編譯選項。`CFLAGS` 設定了針對目標架構（例如 ARM Cortex-M3）的編譯參數。

### 2. 目標與依賴設定

```makefile
TARGET = os.bin
all: $(TARGET)
```
這部分設置了 Makefile 的默認目標。當你執行 `make` 時，將生成名為 `os.bin` 的燒錄檔案。

### 3. 生成最終二進位檔案

```makefile
$(TARGET): os.c startup.c context_switch.S
	$(CC) $(CFLAGS) $^ -o os.elf
	$(CROSS_COMPILE)objcopy -Obinary os.elf os.bin
	$(CROSS_COMPILE)objdump -S os.elf > os.list
```
這些規則說明了如何從源碼生成 `.elf` 檔案，然後將其轉換為二進位檔案 `.bin` 以供燒錄。`objcopy` 用來將 `.elf` 轉換為 `.bin` 格式，`objdump` 則生成可讀的反匯編檔案 `.list`。

### 4. 使用 QEMU 模擬運行

```makefile
qemu: $(TARGET)
	@qemu-system-arm -M stm32-p103 -nographic -kernel os.bin
```
qemu 目標使你可以在虛擬機上運行嵌入式系統的二進位檔案，進行測試和調試。

### 5. 清理生成檔案

```makefile
clean:
	rm -f *.o *.elf *.bin *.list
```
clean 目標用來刪除編譯過程中生成的中間檔案，確保每次編譯從乾淨的環境開始。

### 實際應用

使用 Makefile 自動化編譯過程，不僅節省時間，也避免了手動執行繁瑣的命令，尤其是在專案檔案較多時。當修改了源碼後，只需執行 `make` 指令，Makefile 會自動處理依賴關係，進行增量編譯，生成最終的 `.bin` 檔案，並可以直接進行燒錄或模擬運行。

這樣的流程尤其適用於嵌入式開發中，配合交叉編譯工具鏈（如 `arm-none-eabi-gcc`）和燒錄工具（如 `st-flash`），讓開發過程更加高效與一致。

--------------------------------------------------
# 7. STM32 MCU的啟動與執行

## 7.1 固定記憶體映射與程式燒錄儲存位置

在 STM32 系統中，**記憶體的配置**和**程式碼的儲存位置**對於系統的啟動與運行至關重要。本章將介紹 STM32 MCU 的**固定記憶體映射**，並深入探討如何將應用程式燒錄到 Flash 記憶體中，以及如何通過**向量表重映射**將控制權引導到程式碼區域。我們還會討論如何使用鏈接器腳本自定義程式碼的存放位置，並確保啟動過程中正確執行程式。

通過了解這些基礎配置，開發者可以更好地掌控程式碼的儲存與執行流程，進而提高系統的穩定性和運行效率。

### 1. 記憶體硬體配置

STM32 MCU 的記憶體配置是靜態且固定的，這意味著記憶體的基本映射（memory mapping）在硬體層級已經預先定義。**每個記憶體區域的起始地址和大小由硬體設計決定，無法任意更改**。MCU 在啟動和運行過程中會依照這些固定的映射來存取記憶體區域。

這些固定的記憶體區域配置決定了程式碼、資料與堆疊等在記憶體中的具體位置，從而確保系統的穩定運行。常見的記憶體映射區域包括：

- **Flash 記憶體**  
  這部分記憶體作為**程式碼區（Code Area）**，儲存應用程式的程式碼。當程式被燒錄後，程式碼會存放在此區域，通常其起始地址為 `0x08000000`（通過 ICode/DCode 總線訪問）。Flash 記憶體為非揮發性儲存裝置，即使電源關閉，資料仍會保留。

- **SRAM**  
  **資料區（SRAM）** 用來儲存程式運行過程中的暫時性資料，類似於電腦中的 RAM。程式運行時，變數和中間運算結果都會存放在 SRAM 中。其通常起始地址為 `0x20000000`（通過系統總線訪問）。不同於 Flash 記憶體，SRAM 為易失性記憶體，當電源關閉時，資料會被清除。

Cortex®-M4 處理器會通過 ICode 總線來擷取重置向量，這意味著啟動區域必須位於程式碼區域（通常是 Flash 記憶體）。

這些記憶體區域的配置由硬體設計決定，並確保在 STM32 MCU 啟動和運行過程中，程式碼、資料及堆疊能夠正確地被存取。這樣的配置不僅有助於提升系統運行效率，避免存取衝突，還能提高系統的穩定性。不同區域的特性（如易失性與非易失性）使得 MCU 在運行時能夠高效且可靠地運作。

---

### 2. 啟動文件與向量表

韌體燒錄檔是經由編譯與鏈結生成的檔案，其中除了主程式的 `.o` 檔案外，還需要依賴兩個重要的組件：
1. **啟動文件（Startup File）**
2. **鏈接腳本（Linker Script, `.ld` File）**

#### 向量表的定義與作用

以 STM32 為例，**啟動文件**負責 MCU 啟動初始化，包含一段陣列（array），用來描述**向量表**的結構。向量表的定義由 ARM Cortex-M 系列規範統一規定，其主要作用包括：
- 提供系統的**堆疊指標 (Stack Pointer, MSP)** 初始值。
- 定義**重置向量 (Reset Vector)** 和各種**中斷服務例程 (ISR)** 的入口地址。

向量表的內容通常以 C 語言或匯編程式碼在啟動程式碼（Startup Code）中定義，例如：
```c
__attribute__((section(".isr_vector")))
const uint32_t g_pfnVectors[] = {
    (uint32_t)&_estack,      // 主堆疊指標初始值
    (uint32_t)Reset_Handler, // 重置向量
    (uint32_t)NMI_Handler,   // 非遮蔽中斷處理函數
    // 其他中斷向量...
};
```
#### 向量表的位置與記憶體映射

在編譯與鏈結過程中，**鏈接腳本 (`.ld` File)** 決定了向量表的位置，一般會將向量表放置於 Flash 記憶體的起始地址 (`0x08000000`)，例如：
```ld
.isr_vector :
{
    KEEP(*(.isr_vector))
} > FLASH
```
這段描述的含義是：

1. 向量表的內容來自 `.isr_vector` 段。
2. 向量表被指定放置於 Flash 區域中，起始地址通常為 `0x08000000`（STM32 的默認 Flash 起始地址）。

---

### 3. 程式碼與啟動過程配置

在 STM32 MCU 中，程式碼通常燒錄到內部的 Flash 記憶體，處理器預期向量表從地址 `0x00000000` 開始，這是所有 MCU 預設的啟動行為，通常指向中斷處理程序和重置處理程序等。 然而，STM32 的 Flash 記憶體實際起始地址為 `0x08000000`，而非 `0x00000000`，這是處理器的預設啟動流程。

為了確保處理器可以從 `0x00000000` 開始讀取向量表，系統會進行 **向量表的重映射**，將控制權轉交至 Flash 記憶體的程式碼區 `0x08000000` 開始執行。總結來說，MCU 會在啟動時將 Flash 的起始地址 `0x08000000` 映射到 `0x00000000`，詳細**記憶體映射**內容會在 **7.?? STM32 開機過程中的記憶體映射配置** 章節中進一步解說。

為了滿足不同應用需求，使用者可以透過 **鏈接器腳本(Linker Script)** 自定義程式在 Flash 中的存放位置，例如指定應用程式的啟動地址或將不同模組配置到特定區域，從而保證程式能正確加載並執行。


## 7.2 程式燒錄與開機配置

### 程式燒錄概述

程式燒錄是將經過編譯的應用程式載入 STM32 微控制器的 **Flash 記憶體** 中，並使其在系統啟動時執行。不同於傳統的操作系統啟動流程，STM32 微控制器的啟動過程更多地依賴硬體設置來決定啟動順序。根據燒錄工具和開機配置，開發者可以選擇適合的方式將程式燒錄到 MCU 中，並設定開機模式來確保程序的正確啟動。

### 1. 程式燒錄方式

根據開發需求，STM32 提供了多種方式來將程式燒錄到 Flash 記憶體中。以下是常見的燒錄方式：

- **SWD (Serial Wire Debug)**：
  這是 STM32 最常用的燒錄和除錯方式之一。透過 SWD 接口，開發者可以使用 STM32CubeIDE 等開發工具進行程式燒錄和除錯。SWD 是一個高速且穩定的連接方式，特別適合開發過程中進行程式更新和測試。

- **UART 或 USB (DFU 模式)**：
  STM32 支援透過內建的 **Bootloader** 進行程式燒錄，這一功能可透過 **USART** 或 **USB** 接口啟用。USB DFU（Device Firmware Upgrade）模式特別適合在沒有專門燒錄工具的情況下進行韌體更新，常見於遠端設備或需要經常更新程式的應用中。

### 2. 程式燒錄過程

無論選擇哪種燒錄方式，程式燒錄的基本過程如下：

1. **選擇燒錄方式**：根據需要選擇適當的燒錄介面（如 SWD、UART 或 USB）。
2. **連接設備並燒錄程式**：將開發工具與 STM32 連接，並透過選擇的介面將編譯好的程式燒錄到 STM32 的 **Flash 記憶體** 中。
3. **開機模式設定**：燒錄完成後，系統根據設定的開機模式來決定從哪個記憶體區域啟動程式。這通常涉及設置 **BOOT0** 和 **BOOT1** 引腳。

燒錄完成後，程式會被儲存在 Flash 記憶體中，並在系統啟動時自動執行。

### 3. 開機模式與記憶體選擇

STM32 的開機模式由硬體引腳（如 **BOOT0**）和內建的 Bootloader 共同決定。這些模式決定了 STM32 在啟動時會從哪個記憶體區域執行程式。

- **BOOT0 引腳**：此引腳用來選擇開機模式，當 **BOOT0** 設為高電位時，STM32 會進入 Bootloader 模式，從外部接口（如 UART 或 USB）更新程式；當 **BOOT0** 設為低電位時，STM32 會從 Flash 記憶體（通常為地址 0x08000000）啟動應用程式。

#### 開機模式選擇

STM32 微控制器根據 **BOOT0** 和 **BOOT1** 引腳的設置，可以選擇以下開機模式：

1. **Boot from Main Flash Memory**：
   當 **BOOT0** 設為低電位（通常為 0）時，STM32 會從主 Flash 記憶體的起始位置讀取並執行程式。這是 STM32 的預設開機模式，適用於正常的應用執行。

2. **Boot from System Memory (Bootloader)**：
   在這種模式下，STM32 會從系統記憶體中的 Bootloader 區域啟動。這是進行韌體更新或程式燒錄時的常用模式，通過這種方式可以避免在燒錄過程中啟動已安裝的應用程式。

3. **Boot from Embedded SRAM**：
   在此模式下，STM32 從內部 SRAM 記憶體啟動程式，通常用於開發過程中的測試或除錯。

#### BOOT0 和 BOOT1 引腳配置

STM32 系統啟動時，會根據 **BOOT0** 和 **BOOT1** 引腳的電位來選擇開機模式。具體配置如下：

- **BOOT0**：此引腳專門控制開機模式。當設為高電位（1）時，STM32 會進入 Bootloader 模式；設為低電位（0）時，STM32 會從 Flash 記憶體啟動。
  
- **BOOT1**：此引腳在某些 STM32 型號中用來進一步控制開機模式，並且在非開機階段也可作為一般 GPIO 使用。開機時，STM32 會根據 **BOOT0** 和 **BOOT1** 引腳的組合來選擇合適的啟動方式。

這些引腳的設定會在系統啟動時被鎖存，確保系統根據硬體配置選擇正確的開機模式。

### 4. 開機配置範例

假設開發者希望 STM32 從 **Flash 記憶體** 啟動應用程式，則可以將 **BOOT0** 引腳設為低電位（0）。在此配置下，MCU 啟動時會直接執行 Flash 記憶體中的程式。

如果需要更新程式或進行除錯，則可以將 **BOOT0** 設為高電位（1），這樣 MCU 會進入 Bootloader 模式，並可通過串列接口（如 USART 或 USB）進行程式燒錄。

### 5. 常見問題與注意事項

在進行程式燒錄和開機配置時，開發者可能會遇到一些常見問題，以下是一些解決方法：

- **燒錄過程失敗**：如果燒錄過程中出現中斷，可能是因為燒錄工具或連接接口不穩定。此時可檢查硬體連接，或嘗試重新啟動燒錄工具。
  
- **開機模式設定錯誤**：開機前，請檢查 **BOOT0** 和 **BOOT1** 引腳的電位，確保它們與所需的開機模式一致。

- **程式更新失敗**：若程式更新失敗，可以使用 **SWD** 接口進行故障排除，或重啟燒錄工具進行重新燒錄。


## 7.3 Linker Script 與 STM32 記憶體配置

### 1. Linker Script 在嵌入式系統啟動中的角色與作用

Linker Script 是一個配置檔案，用於指導編譯器如何將程式碼、資料等放置到特定的記憶體區域。它基本上告訴編譯器：
- **程式碼放置在何處**（例如 Flash 記憶體的起始位置）。  
- **資料區域應該如何分配**（例如 SRAM 的分配）。
- 如何設置不同區域的邊界和大小。

Linker Script 在嵌入式系統的啟動過程中扮演著關鍵角色，確保程式碼和資料被正確地放置在 MCU 啟動時可訪問的記憶體區域。由於 MCU 的啟動模式（由 BOOT0 和 BOOT1 設置決定）決定了啟動時從哪個記憶體區域（如 Flash、SRAM 或系統記憶體）尋找並執行程式碼，Linker Script 必須根據這一啟動模式來安排程式碼的儲存位置，從而保證系統能夠順利啟動並執行。

---

### 2. Linker Script 與記憶體映射的運作流程

#### 1. Flash 程式碼與 SRAM 資料分配的運作邏輯

根據 Linker Script 的設定，編譯器會將記憶體分配如下：  

- **程式碼 (.text)**：儲存於 FLASH 記憶體中，這是不可揮發記憶體，斷電後內容不會消失。  
- **已初始化資料 (.data)**：在編譯過程中，這些資料的初始值會被儲存於 FLASH，開機時由 **startup code** 將資料複製到 SRAM，以便快速存取和修改。  
- **未初始化的變數 (.bss)**：.bss 區域的變數不會被燒錄到 Flash。當 MCU 開機並執行 **startup code** 時，這些變數會被分配到 SRAM 中，並且會被初始化為 0。

#### 2. STM32 系統的啟動模式與記憶體選擇

在 STM32 系統中，開機模式會決定 MCU 從哪個記憶體區域開始執行程式：

1. **BOOT0 = 0，BOOT1 = X**  
   MCU 從主 FLASH 的 `0x08000000` 開始執行。這是常見的應用模式，使用 Flash 作為主要儲存位置。

2. **BOOT0 = 1，BOOT1 = 0**  
   MCU 從系統記憶體（`0x1FFF0000`）啟動，通常用於執行內建的 Bootloader，例如進行固件升級或重新燒錄。

3. **BOOT0 = 1，BOOT1 = 1**  
   MCU 從 SRAM 啟動（`0x20000000`）。這種模式主要用於測試或特殊應用，例如直接從 SRAM 中執行程式碼。  

**注意：** 如果程式是以 Flash 為基準編譯（使用 `flash.ld`），但 BOOT 模式設定為 SRAM 啟動（`BOOT0 = 1, BOOT1 = 1`），MCU 將無法找到並執行對應的程式碼，導致程式執行失敗。

**觀念釐清：** 當 **BOOT0 設為 0** 時，為何仍然可以透過 ST-Link 燒錄程式？  

事實上，這是因為 ST-Link 燒錄工具直接與 MCU 的記憶體單元進行通訊，不依賴 BOOT 模式。其細節如下：

- **ST-Link 的燒錄過程**  
  ST-Link 可以直接控制 MCU 的 Flash 或 SRAM 進行燒錄作業，因此無論 BOOT0 的狀態如何，都可以正常燒錄。  

- **MCU 上電啟動**  
  當 MCU 上電啟動時，BOOT0 的狀態才會決定 MCU 的啟動來源（例如執行 Flash 中的程式或進入 Bootloader）。

---

### 3. Linker Script 的基本結構

Linker Script 主要由兩個部分構成：**MEMORY** 和 **SECTIONS**。  
#### 1. MEMORY 設定
在 Linker Script 中，首先會定義不同記憶體區域的大小與起始地址。例如：

```ld
MEMORY
{
    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 1M
    SRAM (rw) : ORIGIN = 0x20000000, LENGTH = 128K
}
```
- FLASH 區域設置為讀取（rx）權限，起始地址為 0x08000000，長度為 1MB。  
- SRAM 區域設置為讀寫（rw）權限，起始地址為 0x20000000，長度為 128KB。

#### 2. SECTIONS 設定
在 SECTIONS 部分，定義了程式碼、資料等應該放在哪些記憶體區域。例如：

```ld
SECTIONS
{
    .text :
    {
        *(.text) /* 將所有程式碼區段放到 .text 段 */
    } > FLASH

    .data :
    {
        *(.data) /* 將已初始化資料放到 .data 段 */
    } > SRAM
}
```
這裡，`.text` 部分的程式碼將被放置到 FLASH 記憶體區域，而 `.data` 中的已初始化資料將放置到 SRAM 記憶體區域。

---

### 4. 實務範例：Linker Script 與記憶體配置的關聯

假設你的程式需要以 SRAM 為主要執行區域，可以使用以下的 `ram.ld`：


```ld
MEMORY
{
    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 1M
    SRAM (rw) : ORIGIN = 0x20000000, LENGTH = 128K
}

SECTIONS
{
    .text :
    {
        *(.text) /* 程式碼區 */
    } > FLASH

    .data :
    {
        *(.data) /* 已初始化的資料 */
    } > SRAM
}
```
這樣的配置適合用於 SRAM 模式，程式將儲存在 SRAM 中並直接執行。然而，因為 SRAM 是揮發性記憶體，斷電後資料會消失，所以這種模式主要用於測試或特殊用途。












## 7.? Flash 記憶體與啟動過程

在 **STM32F4** 微控制器中，程式碼被燒錄到 **Flash 記憶體** 中。這樣，即使在電源關閉後，程式碼也不會丟失。Flash 記憶體是非揮發性的存儲區域，適合用來儲存永遠需要保留的程式碼與資料。程式碼的燒錄過程通常通過內建的 **Bootloader** 完成，並且可以通過多種接口（如 **SWD**、**UART** 或 **USB**）來進行燒錄。

### 啟動過程概覽

當 STM32F4 MCU 上電或重置時，微控制器會從預設的記憶體地址開始執行程式。這個過程涉及以下幾個重要步驟：

1. **中斷向量表**：處理器會先讀取位於 **0x0000 0000** 地址的中斷向量表，這是啟動過程的起點。中斷向量表中包含了程式執行的起始地址和處理中斷的相關信息。
2. **重置處理程序（Reset Handler）**：中斷向量表的第一個條目通常會指向 **Reset Handler**，這是 MCU 啟動後首先執行的程式段，負責初始化系統。
3. **程式碼執行位置**：在進行重置後，程式碼會從特定的記憶體區域（通常是 Flash 記憶體）開始執行。

### 中斷向量表與啟動位置

中斷向量表通常位於 **0x0000 0000** 地址，這是 STM32 微控制器的固定啟動位置。當 MCU 開機或重置時，它會自動跳轉到這個地址，開始執行啟動程式。根據 MCU 的配置，程序的執行可以從以下位置開始：

- **Flash 記憶體**：通常，程式碼會從 **0x0800 0000** 開始執行，這是 **Flash 記憶體** 的預設起始位置。
- **SRAM 或其他位置**：在某些特殊情況下，處理器也可以配置為從其他記憶體區域（如 SRAM）啟動。

### Flash 記憶體分區與啟動 Bank 選擇

**STM32F4** 系列微控制器的 Flash 記憶體被分為兩個區域，稱為 **Bank 1** 和 **Bank 2**。這樣的設計提供了更大的靈活性，特別是在需要進行韌體升級或應用程序冗餘的場合。

- **預設啟動 Bank**：在 STM32F4 系列中，默認情況下，程式碼會從 **Bank 1**（位於地址 **0x0800 0000**）開始執行。
- **改變啟動 Bank**：如果需要從 **Bank 2** 啟動，可以透過設定 **BFB2**（Boot Flash Bank）選項來實現。當 **BOOT** 引腳設定為從主 Flash 啟動，並且 **BFB2** 被啟用時，系統會跳轉到 **Bank 2** 開始執行程式。

這樣的設計使得 **STM32F4** 更加靈活，開發者可以根據需要選擇不同的 **Bank** 來執行程式，這對於那些需要定期升級或進行故障恢復的應用特別有用。

### Flash 記憶體啟動過程的詳細步驟

1. **上電與重置**：當 STM32F4 MCU 上電或經過重置時，微控制器會自動從預設的 **0x0000 0000** 地址讀取中斷向量表。
2. **初始化程序**：MCU 開始執行初始化程序，這會初始化系統、設定時鐘、配置外部外設等。
3. **執行程式**：一旦初始化完成，控制權將轉交給位於 **Flash 記憶體** 中的應用程式代碼，程式開始執行。

這些步驟確保了 STM32F4 能夠在每次開機或重啟時準確無誤地從 Flash 記憶體中加載並執行程式碼。

### 範例：Flash 記憶體配置

如果你希望選擇從 **Bank 2** 啟動程式，可以設定 **BFB2** 標誌。設定步驟如下：

```ld
// 在 linker script 中設定預設的 Flash 記憶體 Bank
MEMORY
{
    FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 1M
    SRAM (rw) : ORIGIN = 0x20000000, LENGTH = 128K
}
```

並在 `SystemInit` 函數中確認設置為從正確的 Bank 啟動。

```c
// 設定啟動 Bank（例如：Bank 2）
void SystemInit(void)
{
    if (BFB2 == SET)
    {
        // 從 Bank 2 啟動
        FLASH->ACR |= FLASH_ACR_BFB2;
    }
    else
    {
        // 預設從 Bank 1 啟動
        FLASH->ACR &= ~FLASH_ACR_BFB2;
    }
}
```
這樣，當 MCU 上電後，它將根據設置選擇正確的 Flash Bank 來啟動程式。







## 7.1 MCU的開機流程

當電源接通或 MCU 從重置狀態中恢復時，STM32 會依循一個預設的開機流程，依序執行各項啟動程序。這個過程從 MCU 的初始化開始，然後進行系統資源的配置，並最終開始執行應用程式。

### 2. 啟動程式

當 MCU 上電或重置後，STM32 的啟動程式碼（Startup Code）會先被執行。接著，硬體會從經映射至 `0x00000000` 的記憶體位置（通常是 Flash 記憶體中的 `0x08000000`）讀取向量表中的初始值並進行初始化，這些初始值包括堆疊指標的初始值和重置向量。這裡的硬體是指整體的 MCU 硬體設計，包括 STM32 的處理器（ARM Cortex-M4 核心）以及內建的啟動機制。

隨後，啟動程式會進行一些必要的硬體初始化工作，這包括配置 GPIO、啟動外設等。另一個關鍵步驟是進行系統時鐘的設定，這可以確保 MCU 能夠依照設定的時鐘源運行，並且後續的外設和運算能夠在穩定的時鐘頻率下進行。

最後，啟動程式會返回並讀取向量表中的中斷向量表（Interrupt Vector Table），對其進行初始化，並最終跳轉至 `main` 函數。

#### 向量表內容的初始化

1. **堆疊指標初始化**

   堆疊指標初始化是啟動過程中的初步設置。 

   **堆疊指標（Stack Pointer, MSP）** 是指向堆疊區域的指標，該區域用來儲存局部變數、函數返回地址等資料。在 STM32 這類 MCU 中，堆疊區域通常位於 SRAM 的高端，並從高地址向低地址增長，與資料段（通常由低地址向高地址增長）相反，這樣設計有助於避免堆疊溢出時覆蓋其他資料。

   堆疊指標的初始值儲存在 `0x00000000`，並指向 SRAM 的高端。初始化後，堆疊指標使系統能夠正確使用堆疊區域來儲存資料，執行函數調用及局部變數存儲等操作。

2. **重置向量**

   接著，MCU 會讀取**重置向量 (Reset Vector)**，它是向量表中的第二個條目，通常儲存在 `0x00000004` 這個位置，指向啟動程式碼（Startup Code）的入口地址。

   重置向量是一個函式指標，當 MCU 上電或重置時，硬體會自動跳轉到這個地址，開始執行啟動程式，並進行後續的初始化工作。這是啟動程式執行的開始。

3. **啟動程式的執行**

   啟動程式碼通常儲存在 Flash 記憶體中，並在執行時進行必要的初始化工作，包括：

   - **初始化堆疊與靜態資料區域**：
     - 設定 `.data` 段的初始值：這部分存放已初始化的全域變數或靜態變數，啟動程式會將它們從 Flash 複製到 SRAM，確保變數在執行時具有正確的初始值。
     - 清空 `.bss` 段：這部分包含未初始化的全域變數和靜態變數，啟動程式會將 `.bss` 段中的變數初始化為零，避免未初始化的變數存儲"垃圾值"（garbage value），確保其從一開始就是已知的零值。

---

### 3. 硬體初始化與時鐘設定

在 STM32 的啟動程式中，做完向量表的初始化工作後，會進行一系列硬體初始化工作，以確保系統能夠正常運行，這些步驟包括時鐘配置、記憶體映射設置以及外設的初始化等。

- **時鐘源選擇與系統時鐘設置**：開機時，MCU 預設會使用 **HSI（高速內部振盪器）** 作為第一階段的時鐘源。HSI 的主要優勢是啟動速度快，能在開機後迅速提供時鐘信號。隨後，系統會根據設置切換至 **HSE（外部高速振盪器）**，如果有外部晶振可用，這樣可以提供更高的精確度和穩定性。這樣的設置有助於在 MCU 開機後快速啟動，同時在系統穩定運行時切換到更精確的外部時鐘源。

  - 當使用外部晶振時，**HSE** 成為系統的主時鐘源，並進入 **PLL（相位鎖定迴路）**，以產生所需的高頻時鐘，供應給處理器和外設。
  - 若系統無需高精度時鐘，MCU 也可以繼續使用 HSI 作為系統時鐘。

- **中斷管理與外設初始化**：除了時鐘配置外，初始化階段還會處理中斷控制器的設置，並配置外設如定時器、GPIO 和通信接口（如 UART、SPI）等。這些外設的初始化確保在 MCU 開機後，所有硬體能夠正常工作，並準備好執行預設的應用程式。

- **堆疊大小設置**：此外，初始化過程中會設定堆疊區的大小，這對於中斷處理和遞歸調用等操作至關重要，能確保 MCU 在執行過程中不會發生堆疊溢出。

這些初始化步驟確保了 MCU 能夠穩定運行，並準備好執行應用程式的主邏輯。

---

### 4. 中斷向量表初始化與執行應用程式

中斷向量表的初始化理論上可以在硬體初始化和時鐘設定之前進行，但通常會在這些步驟之後進行。這是因為在處理中斷時，系統的時鐘和基礎硬體需要先準備好，確保中斷處理的正常運作。

中斷向量表中的每一個中斷處理函式對應一個特定的中斷源，這些中斷源來自於 MCU 的內部外設（如定時器、UART、SPI 等），也可以來自外部中斷源（例如按鍵、感測器等外部設備）。當外部事件（如按鍵按下）發生時，對應的中斷源會觸發中斷，並根據中斷向量表中的配置，將控制權轉移到對應的中斷處理函式（ISR）。這樣的設計使得 MCU 能夠高效、即時地響應外部事件並做出處理。

在 STM32 中，為了處理多個中斷源的同時觸發，系統會根據中斷的優先級進行排程。每個中斷源有其對應的優先級，優先級數值越小，表示該中斷的處理權越高。當多個中斷同時發生時，MCU 會優先處理高優先級的中斷，而低優先級的中斷會被延遲處理，直到高優先級的中斷處理完畢。

中斷向量表的初始化過程包括設置中斷向量表的基址，通常將其指向 Flash 記憶體的起始地址。這確保了當中斷發生時，系統能正確處理各種中斷事件。

完成中斷向量表初始化後，啟動程式會跳轉到 `main()` 函式，開始執行應用程式的代碼。此時，系統已經準備好並擁有所需的硬體資源，能順利運行應用程式。

**補充**：若在初始化過程中發生錯誤或異常，通常會跳轉到預設的錯誤處理例程，這有助於調試和故障排查。



---

### 3. 向量表的重映射（Vector Table Remapping）

向量表的重映射由處理器的 **向量表偏移暫存器**（Vector Table Offset Register，簡稱 VTOR）來控制。

在 STM32 重置啟動時，處理器的 **VTOR** 默認設置為 `0x00000000`，這意味著處理器會從這個地址開始執行程式。此時，`0x00000000` 地址通常包含向量表，其中的第一個項目是 **重置向量**（**Flash 區域** 的起始位置，例如：`0x08000000`），而`0x08000000`又會指向 `Reset_Handler` 函式的地址。通常，**重置向量**這個位置的設置通常由 **鏈接器腳本**（`.ld` 文件）的 Entry 來決定。

因此，當處理器啟動時，會發現 **VTOR** 默認指向 `0x00000000`，然後處理器會從這個地址讀取重置向量。該重置向量會指引處理器更新 **VTOR** 的值，將其設置為 Flash 的起始地址（例如：`0x08000000`），並從該位置開始執行程式。這個過程就稱為 **向量表的重映射**。

#### 映射（Mapping）
映射指的是將一個記憶體區域的內容指向另一個區域，而非將資料實際搬移。當系統啟動時，處理器原本會從 `0x00000000` 開始執行程式，但向量表卻存放於 `0x08000000`。為了讓處理器能正確讀取向量表，系統會將 `0x00000000` 映射到 `0x08000000`。這表示，當處理器讀取 `0x00000000` 時，實際上讀取的是 `0x08000000` 的資料；當讀取 `0x00000004` 時，則讀取 `0x08000004` 的資料。

#### 為什麼要映射
在 STM32 MCU 中，向量表通常存放於 Flash 記憶體（從 `0x08000000` 開始），並包含中斷與異常的處理函式地址。如果處理器從 `0x00000000` 開始執行，會找不到向量表，無法初始化中斷處理函式。為了保證啟動時處理器能正確處理中斷，系統會將 `0x08000000` 映射到 `0x00000000`，使處理器能在啟動時從 `0x00000000` 讀取正確的向量表地址，並順利開始中斷初始化。

當向量表執行完畢後，處理器會跳過 `0x00000000` 後的部分（通常為空白或其他程式碼），開始執行主程式（如 `main()`）。

## 7.3 STM32 開機過程中的記憶體映射配置





----------------------
#### 向量表重定位
使用者可以根據需求將向量表從預設的 Flash 記憶體位置 `0x08000000` 移至 SRAM 或其他記憶體區域。例如，在 Bootloader 與應用程式之間切換過程中，可能需要重定位向量表，指向不同的中斷處理函式。

Bootloader 是在應用程式之前執行的程式，負責初始化工作，如檢查應用程式是否有效，或從外部設備讀取並燒錄新程式。這時，向量表的重定位能確保不同階段的中斷處理。

#### 重映射機制
重映射通常通過修改 **VTOR（向量表基址暫存器）** 實現。該暫存器告訴處理器向量表的位置，並可在不同階段修改。例如：
- 在 Bootloader 執行時，向量表可能位於 `0x08000000`（Flash 記憶體的起始位置），此時 Bootloader 負責處理中斷。
- 當 Bootloader 跳轉到應用程式時，會將 VTOR 設為應用程式的起始位置（例如 `0x08010000`），這樣應用程式就會負責處理中斷。

這種設計確保了啟動過程的靈活性及中斷處理的可靠性。

在 STM32 MCU 的開機過程中，記憶體映射配置是啟動程序能夠正確執行的關鍵因素之一。這一章節將深入探討 STM32 在開機時如何配置記憶體，並根據不同的需求動態調整記憶體區域，這些配置確保了 MCU 可以順利啟動並執行程式。透過這些配置，MCU 能夠選擇性地從 Flash 記憶體啟動並根據需要切換到 SRAM 或外部記憶體。

### 1. 開機初始化與記憶體映射配置

在 STM32 開機時，記憶體映射的配置過程通常從啟動程式（Bootloader）開始。當 MCU 加電後，處理器會首先從預定的啟動位置（通常是 Flash 記憶體的起始位置 0x08000000）讀取並執行啟動程式。此程式負責初始化系統，包括記憶體映射配置。

- **啟動程式的角色**：啟動程式負責配置記憶體映射，確保系統能夠使用各種記憶體區域（如 Flash、SRAM 和外部記憶體）。此時，MCU 已經根據預設的固定配置選擇了 Flash 作為主要執行區域。
- **記憶體映射配置**：啟動程式會將記憶體映射配置到 MCU 的不同區域。例如，它會將 Flash 記憶體映射到 0x08000000，並將 SRAM 映射到 0x20000000，這是所有 STM32 MCU 的基本配置。

---

### 2. 記憶體段的初始化與動態配置

在 MCU 啟動後，啟動程式會根據需求動態配置記憶體區域，並將記憶體段映射到對應的內存區域。

- **堆疊和資料段的初始化**：啟動程式會初始化堆疊（Stack）和資料段（Data Segment）。堆疊區域通常位於 SRAM 中，資料段會從 Flash 複製到 SRAM，確保資料段能夠在運行期間被正確使用。
- **堆疊配置**：啟動程式會設定堆疊指標（Stack Pointer）為 SRAM 的起始位置，並確保堆疊指標指向有效的記憶體範圍。
- **資料段映射**：資料段會從 Flash 複製到 SRAM，這樣可以確保程式的變數在運行時能夠動態存取。

---

### 3. 記憶體重映射機制

STM32F4 提供了一個特殊機制，允許將不同記憶體區域映射到程式碼區的起始地址 **(0x0000 0000)**，由 **SYSCFG 控制器** 中的 **SYSCFG_MEMRMP 暫存器** 控制。這個重映射機制使得 MCU 可以根據開機模式的不同，將不同記憶體區域映射到程式碼區的起始地址。

#### 可重映射的記憶體區域包括：

- **主 Flash 記憶體**：當處於正常應用程式模式時，Flash 記憶體會被映射到起始地址 **0x0800 0000**。
- **系統記憶體**：包含內建的 Bootloader，當進入 Bootloader 模式時，會映射到 **0x1FFF 0000**。
- **內建 SRAM1**：可以作為記憶體映射的一部分，尤其是在除錯模式或特殊應用下。
- **外部記憶體（如 NOR/PSRAM）**：支持重映射到程式碼區起始位置，用於一些需要更大記憶體容量的應用。

這使得 STM32F4 可以靈活地使用內外部記憶體，並且在高效能需求的應用中，通過 **ICode 匯流排** 來提高存取效能。

---

### 4. 開機模式下的記憶體映射

根據不同的開機模式，STM32F4 的記憶體映射配置會有所不同。以下是主要的記憶體區域映射範例：

| 地址範圍                    | 開機模式下的記憶體映射     | 備註                             |
|----------------------------|---------------------------|----------------------------------|
| 0x2000 0000 - 0x2001 FFFF   | **SRAM1** 和 **SRAM2**      | 這部分記憶體的地址不會改變       |
| 0x0800 0000 - 0x080F FFFF   | **Flash 記憶體**           | 在主 Flash 開機模式下存儲程式碼  |
| 0x1FFF 0000 - 0x1FFF 77FF   | **系統記憶體**             | 包含內建 Bootloader              |
| 0x0000 0000 - 0x001F FFFF   | **Flash 記憶體** 或 **SRAM1** | 可以重映射外部記憶體或 Flash    |

開機後，記憶體映射會根據需求進行動態調整。這意味著，系統可以在不同階段根據運行狀況切換記憶體區域，甚至可以在某些情況下將記憶體區域進行重映射。

例如，在某些 STM32 系列中，啟用外部記憶體後，系統可根據需求將其映射到指定區域（如 0x60000000）。這樣可以在系統運行過程中根據不同的需求靈活選擇使用外部記憶體或內部記憶體。

記憶體重映射：MCU 還可以在啟動過程中重映射記憶體，例如，將 Flash 記憶體的起始地址（0x08000000）重映射到其他位置，這通常是為了應對特殊的啟動需求或確保系統的穩定運行。

---

### 5. 記憶體管理單元（MMU）與映射

在高階的 STM32 系列中，處理器支持記憶體管理單元（MMU），使得記憶體映射配置更加靈活。MMU 允許根據運行中的需求動態改變記憶體映射，有助於系統的記憶體管理與效能優化。

- **MMU 的作用**：MMU 允許處理器在執行過程中動態改變記憶體的映射，這對於系統的記憶體管理與效能優化有很大的幫助。這意味著，在開機後，STM32 MCU 允許根據運行中的需求動態改變記憶體映射，進行更有效的資源分配。
- **記憶體區域保護**：MMU 可以保護某些記憶體區域，防止不當操作對系統造成損害，特別適用於高安全性需求的應用。

---

### 6. 開機後的記憶體配置管理

開機過程中的記憶體配置不僅包括初始化，還需要在系統運行中持續管理，這通常涉及以下幾個方面：

- **堆疊與資料段的動態管理**：在 MCU 運行過程中，堆疊的使用可能會隨著程序的運行而不斷增長或縮小，啟動程式在這一過程中負責動態分配堆疊空間。
- **中斷與異常處理**：當系統處於運行狀態時，向量表的映射會繼續作用，並確保中斷處理程序能夠正確運行。這一過程是 STM32 在運行中的記憶體配置管理的一部分。

## 7.6 Bootloader的運作與配置

### Bootloader 概述

在 STM32 微控制器中，**Bootloader** 是負責啟動過程中的一個關鍵部分。它的主要功能是判斷系統是否需要從預設的應用程式或固件升級程序啟動。具體來說，Bootloader 根據 MCU 引腳的狀態來決定是否進入 Bootloader 模式進行程式燒錄。如果某些特定的引腳（例如 **BOOT0**）設為高電位，MCU 會進入 Bootloader 模式，並允許透過外部接口（如 **USART**、**USB**、**CAN** 等）來更新或燒錄程式碼。

### 進入 Bootloader 模式

STM32 的 Bootloader 行為受 **BOOT0** 引腳影響。當 **BOOT0** 引腳被設為高電位時，MCU 會進入 Bootloader 模式，否則 MCU 會跳過 Bootloader，直接執行 Flash 記憶體中的應用程式。

- **BOOT0 高電位**：進入 Bootloader 模式，允許透過串列接口（如 USART、USB、CAN）進行固件更新。
- **BOOT0 低電位**：跳過 Bootloader，直接執行 Flash 記憶體中的應用程式。

### Bootloader 運作過程

在 STM32 微控制器中，Bootloader 允許使用者選擇不同的串列接口進行韌體更新。根據所選擇的接口，Bootloader 會根據不同的時鐘源來運行。以下是支持的接口與對應的時鐘源：

- **USART 接口**：當使用 USART 介面進行韌體更新時，Bootloader 使用內部 16 MHz 的 **HSI** 時鐘源來進行操作。
- **USB OTG FS 和 CAN 接口**：若使用 **USB OTG FS** 或 **CAN** 進行韌體更新，則需要外部時鐘 **HSE** 來提供時鐘源，時鐘頻率需為 1 MHz 的整數倍，範圍為 4 MHz 到 26 MHz。

這些接口的配置使得 STM32 在進行固件更新時更加靈活，可以根據實際需求選擇合適的通信接口。

### 程式計數器跳轉 (Program Counter Jump)

當 Bootloader 完成固件更新後，它需要將控制權轉交給新燒錄的應用程式。這是透過 **程式計數器（Program Counter, PC）** 的跳轉來實現的。以下是一個簡單的步驟，展示如何從 Bootloader 跳轉到應用程式：

1. Bootloader 完成固件燒錄後，會設置程式計數器指向應用程式的起始位置。
2. 跳轉到應用程式的起始地址，通常是 Flash 記憶體的 **0x0800 0000** 地址。
3. 控制權交給應用程式，開始執行。

程式碼範例：

```c
// 跳轉到應用程式
void jump_to_application(void)
{
    // 設定應用程式的起始位置
    uint32_t app_address = 0x08000000;

    // 設定程式計數器
    void (*app_reset_handler)(void) = (void (*)(void)) (*(volatile uint32_t*) (app_address + 4));
    __set_MSP(*(volatile uint32_t*) app_address);  // 設定堆疊指標為應用程式的起始地址
    app_reset_handler();  // 跳轉到應用程式
}
```

### 常見問題與注意事項

- **如何設定 BOOT0 引腳？**  
  通常可以通過開發板上的跳線或開關來設定 BOOT0 引腳的高低電位。

- **如何選擇適合的時鐘源？**  
  根據所選擇的接口，選擇內部 HSI 時鐘或外部 HSE 時鐘。注意，當使用 USB OTG FS 或 CAN 接口時，需要外部時鐘源。

- **能否自定義 Bootloader？**  
  是的，開發者可以根據需要編寫自定義的 Bootloader，來支持更多的通信接口或特定的功能。



--------------------------------------------------
# 8. 嵌入式系統調試與優化


--------------------------------------------------
# 9. 實際案例與專案開發