# 陳昕佑筆記
- 筆記：<https://hackmd.io/@zoanana990/S1RySgR3A>
- MarkDown語法：<https://hackmd.io/@eMP9zQQ0Qt6I8Uqp2Vqy6w/SyiOheL5N/%2FBVqowKshRH246Q7UDyodFA?type=book>

# 要怎麼更新程式碼到 git 上面
git 檔案分成兩種：有追蹤、沒有追蹤的
- 有追蹤的檔案：可以看到哪些行被你刪掉或增加
- 沒有追蹤的檔案：直接把檔案加到 git 的伺服器裡面

```commandline=
git add <你的檔案名稱>
```

等你把你要修改的檔案加完之後
你就可以把這次的修改寫一個筆記，commit (提交)
```commandline=
git commit
```

等你的筆記做完想要把他上傳到伺服器 (網站版的 github) 的時候
```commandline=
git push
```

# C語言編譯流程
- <https://chivincent.gitbooks.io/c-tutorial/content/chapter2/compile.html>
- <https://medium.com/@alastor0325/https-medium-com-alastor0325-compilation-to-linking-c07121e2803>

- 這整個過程可以大致上分成四個步驟，分別為預處理(pre-processing)、編譯(compilation)、組譯(assembly)與連結(linking)。

## 預處理 (pre-processing)
在這個階段編譯器主要的工作是展開引用的外部檔案、macro 及 define 。

1. 刪除所有的#define並展開所有macro：
	這一步會將所有的macro替換為其對應的值，並且刪除原始的#define定義，因為它已經不再需要保留在最終的編譯文件中
2. 處理所有的預編譯條件(#ifdef, #include等)：
	這包括判斷條件式編譯是否成立，並將引用的外部文件展開。
3. 刪除所有的註解：
	註解對於預處理器而言是無效資訊，因此會在這個階段被移除。
4. 增加行號以及文件識別名：這一步有助於在後續編譯過程中發生錯誤時提供精確的錯誤行數和文件名稱

利用以下指令可以產生預處理後的 main.i檔。
```
g++ -E main.cpp -o main.i
```
實際的 .i 檔案中的內容可能會有數千行，例如"iostream"是一個非常複雜的標準庫頭文件。展開後可以看到許多細節，包括模板、函數原型等。

## 編譯 (compilation)
此階段編譯器會將展開後的程式碼轉換成組合語言。此階段又可以細分成五個小步驟，分別為詞法分析(Lexical Analysis)、語法剖析(Syntax Analysis)、語意分析(semantic analysis)與原始碼最佳化(source code optimization)與程式碼生成與最佳化(code generation and optimization)。

1. 詞法分析或稱為掃描 (Scanning)：將原始代碼轉換成一系列的「詞」(tokens)。
2. 語法剖析或稱為語法分析(Parsing)：根據語法規則，將詞組織成語法樹(Syntax Tree)。
3. 語意分析(Semantic Analysis)：檢查語法樹是否符合語言的語意規則，例如類型檢查、變量的作用域等。
4. 原始碼最佳化(Source Code Optimization)：在生成組合語言之前，對原始碼進行最佳化，以提高性能或減少資源消耗。
5. 程式碼生成與最佳化(Code Generation and Optimization)：將原始碼轉換為組合語言或機器碼，同時進行一些底層的最佳化。

利用以下指令可以將main.cpp直接轉成.s檔案，編譯器會自動執行所有步驟，包括預處理、編譯，最後生成組合語言的.s檔案。不需要手動經過預處理階段，編譯器會處理好。
```
g++ -S main.cpp -o main.s
```
如果原本即有.i檔，則可輸入以下指令，直接將預處理後的.i檔作為輸入，生成組合語言的.s檔。
編譯器會跳過預處理階段，直接從.i檔案開始，執行編譯並生成.s檔案。
```
g++ -S main.i -o main.s
```

### 詞法分析(Lexical Analysis)
- 分割原始碼：將程式碼轉換為一系列的token(詞彙單元)。
- 分類Token：將這些token分為不同的類型，例如保留關鍵字、標示符、常量(數字或字串)、運算符和特殊符號等等。
- 以 a = 3 + 5; 為例：
	- a：標示符（identifier）
	- =：賦值運算符（special symbol）為特殊符號
	- 3 和 5：常量（constant）
	- +：加法運算符（special symbol）為特殊符號
	- ;：分號（special symbol）為特殊符號
- 這些 token 是語言的基本構建塊，編譯器在詞法分析階段將它們識別出來，以便在後續的語法分析和語意分析階段進行處理。

### 語法剖析(Syntax Analysis)
它主要負責將一系列的token組織成語法樹(syntax tree)，以檢查程式碼的語法結構是否正確。
- 構建語法樹：將詞法分析階段生成的token按照語法規則組織成樹狀結構，稱為語法樹(syntax tree)或解析樹(Parse Tree)。
- 檢查語法正確性：確保程式碼符合語言的語法規則，例如運算式的結構是否正確，括號是否匹配等。
- 語法樹的作用：
	- 幫助分析：語法樹能幫助我們分析複雜的運算式或語句結構是否符合語言的語法規則。
	- 後續處理：語法樹可以作為後續步驟(如語意分析、最佳化、生成中間代碼)的基礎。
- 對於 a = 3 + 5; 這段程式碼，語法樹會展示出等式的左邊和右邊的結構，顯示加法運算是如何在等式中進行的。
![alt text](./note%20image/syntax%20tree.png)

### 語意分析 (semantic analysis)
這一階段主要負責檢查語法樹中每個結構的語意是否正確。
1. 靜態語意分析：
- 定義：靜態語意分析是在編譯期間進行的，編譯器會檢查代碼中的語意錯誤。
- 例子：型態檢查（例如，確保你不會將整數和字符串進行相加）、變量的使用前初始化、函數調用時的參數匹配等。
- 檢查項目：型態兼容性、變量的作用域、函數的定義和調用是否匹配等。
2. 動態語意分析：
- 定義：動態語意分析是在程式執行期間進行的，這些錯誤通常無法在編譯期間檢測到。
- 例子：除數為零的錯誤、數組越界、空指針解引用等。
- 檢查項目：程式運行時的錯誤，這些錯誤只有在程式運行時才會顯現出來。

經過分析後，我們可以在文法樹上加上語意型別。

![alt text](./note%20image/commented%20syntax%20tree.png)

### 原始碼最佳化（Source Code Optimization）
現代編譯器通常會有不同層級的最佳化方式。這裡提到的是原始碼層級的最佳化。
例如，在編譯過程中，我們可以知道3+5的值是8因此可以直接用8來取代。
此外，為了提高程式碼轉換為組合語言的效率，通常會使用三位址碼(Three Address Code)來改寫程式碼。

- 三位址碼的基本形式如下，x = y op z，在等號的右側至多只能有一個操作符號(operator)。
例如 a = 4 * 5 + 3 可以轉換成以下的形式，
```
t1 = 4 * 5
t2 = t1 + 3 
a = t2
```
這樣的轉換將複雜的表達式分解為多個簡單的步驟，有助於後續的優化和生成機器碼。

### 代碼生成與最佳化 (code generation and optimization)
根據目標機器的不同，編譯器會選擇最適合的指令來生成並最佳化組合語言。例如，可以用位移操作來取代乘法指令，以提升效能。
- 程式碼生成：這是編譯過程中的最後一步，將中間代碼(如三位址碼)轉換為目標機器的組合語言或機器碼。
- 程式碼最佳化：這是在生成的組合語言中進行的優化過程，旨在提高程式碼的執行效率。這包括選擇最有效的指令和技術來優化生成的程式碼。
	- 例如以位移操作取代乘法：在某些情況下，乘法運算(例如乘以2的次方)可以用位移操作(如左移)來取代，這樣可以提高執行效率，因為位移操作通常比乘法指令執行得更快。


以我們之前的例子 a = 3 + 5 為例，可能會生成如下的組合語言指令：
```
mov eax, 8
mov address_of_a, eax
```
這段組合語言指令首先將加法的結果8存入加法暫存器eax中，然後將eax中的值轉移到另一個暫存器ecx中。

## 組譯 (assembly)
- 組譯是將組合語言轉換成機器碼的過程。組合語言是一種低級語言，其指令與特定的處理器架構相關。組譯器將這些指令轉換為處理器可以理解的二進位機器碼。
- 組譯器(Assembler)會根據指令集架構(Instruction Set Architecture, ISA)中的對照表，將組合語言指令轉換為對應的機器碼指令。這個對照表包含了每條組合語言指令及其對應的機器碼表示。
- 組譯的步驟：
1. 讀取組合語言源碼：組譯器讀取由組合語言編寫的源碼。
2. 解析指令：將組合語言中的每條指令解析為相應的機器碼指令。
3. 生成機器碼：根據指令集架構的對照表，將每條組合語言指令轉換為對應的機器碼。
4. 生成目標檔案：將所有的機器碼指令寫入目標檔案（通常是 .obj 或 .o 檔案）。

經過以下指令，便可以產生目標文件檔(.o/.obj)。
```
g++ -c main.cpp -o main.o
```
補充：.cpp檔或是.i檔生成.o檔，並不一定需要先生成.s檔(.s檔案是組合語言源碼的中間檔案，通常用於調試或分析)；
通用編譯流程描述了從原始程式碼到最終可執行檔案的完整流程，雖然每個階段有其特定的處理目的和生成的檔案。即使某些階段可以被省略（如不生成 .s 檔案），整體流程仍然包括這些步驟。

- 目標文件檔遵循可執行文件格式 (ELF) 來儲存。
	- ELF(Executable and Linkable Format)是一種常見的文件格式，用於儲存可執行檔案、目標檔案、共享庫等。ELF格式廣泛用於UNIX-like系統(如 Linux)。
	- 目標文件格式內部的結構可以包含以下區段：
		1. 代碼區段（Text Segment）：儲存編譯後的機器碼，這是程式的執行代碼部分。
		2. 數據區段（Data Segment）：儲存靜態數據，如全域變數和靜態變數的初始值。
		3. 符號表（Symbol Table）：包含了所有符號（如變數和函數）的名稱和位址，用於連結和調試。
		4. 重定位表（Relocation Table）：用於記錄需要在連結階段調整的地址或位置，以便將程式碼和數據正確地載入到內存中。
	- 目標文件檔遵循特定格式(如 ELF)，並包含不同的區段來儲存程式的機器碼、數據、符號及其他資訊。這些區段在"連結階段"用來生成最終的可執行檔案或庫檔案。
- 分開代碼區段與數據區段的做法，在程式運行時提高了安全性、效能以及資源的使用效率。主要好處：
	1. 執行時可以給予區段不同的讀寫權限(代碼 read-only，數據 read-write)
	2. 增加緩存(cache)的命中率
	3. 讓多個相同的程序 (process) 共用程式區段，以減少記憶體用量。

## 鏈接 (linking)
在編譯程式的過程中，鏈接(linking)是至關重要的一個步驟。這個過程讓編譯器知道程式中外部函數或變數的具體位址。例如，當我們在main.cpp裡使用func.cpp裡的foo() 函數時，編譯器需要確定foo()函數的位置才能正確呼叫它。

### 符號與符號名
在編譯過程中，每個被定義的變數或函數都會有一個名稱，稱為「符號名」(symbol name)，它代表一個特定的變數或函數的位置或地址。

- 符號 (symbol)：編譯器會將程式中的變數、函數、常量等視為符號。這些符號對應著程式中的具體實體，例如變數的記憶體地址或函數的代碼。
- 符號名 (symbol name)：符號的名稱，例如變數名或函數名。編譯器通過這些名稱來追蹤程式中符號的使用和位置。

在鏈接過程中，會進行符號解析(symbol resolution)，確保每個符號名都能被正確解析，並且對應到程式中的正確位置。

### 鏈接過程可以分為兩種形式：
1. 靜態鏈接 (Static Linking)
	- 概念：在靜態鏈接中，所有被引用的函數和變數都會直接整合到最終的可執行檔案內，無需依賴外部的函式庫。
	- 優點：程式是自包含的。這意味著當程式執行時，它不需要依賴任何外部檔案即可正常運作。
	- 缺點：因為所有引用的代碼都包含在可執行檔內，這會增加可執行檔案的大小。
舉例：
如果我們在main.cpp中呼叫foo()函數，靜態鏈接會將func.cpp裡的foo()函數編譯好的機器碼和main.cpp一起合併，生成最終的可執行檔案。

2. 動態鏈接 (Dynamic Linking)
	- 概念：在動態鏈接中，外部函數或變數的地址並不會在編譯期確定，而是推遲到程式執行時才解析。這通常用於共享庫(如 .so 或 .dll)，這些共享庫會在程式執行時動態載入。
	- 優點：減少了可執行檔案的大小，並允許多個程式共享相同的庫檔案，節省記憶體資源。
	- 缺點：程式執行時需要依賴這些動態庫。如果動態庫遺失或版本不對，程式可能會無法正常執行。
舉例：
在動態鏈接的情況下，鏈接器只會記錄 foo() 函數的符號，實際的地址在程式執行時會從共享庫中動態查找。

### 靜態與動態鏈接的符號處理
1. 靜態鏈接：符號名在鏈接過程中解析。當最終的機器碼生成後，符號名不再需要，因為所有的位址已經被固定。
2. 動態鏈接：符號名會保留到程式執行時，用來從動態庫中解析函數和變數。

### 靜態鏈接 vs 動態鏈接的使用場合
1. 嵌入式系統：在某些嵌入式系統中，或者在需要高可靠性的情境中，靜態鏈接較常見。因為它能保證所有依賴在編譯時已經解決，不需要在執行時依賴其他外部檔案。
2. 共享庫的可用性：動態鏈接更適合在需要節省存儲空間的場景中使用，因為多個程式可以共享相同的函式庫，減少記憶體使用量。

### 總結：鏈接的目的
無論是靜態還是動態鏈接，最終的目的都是讓代碼中的外部函數或變數的位址在最終的可執行檔案中明確化，確保程式能夠正確執行。

### 更深入的細節：符號表與重定位表
在編譯階段，我們可以知道會呼叫哪些符號，但不知道它們的具體位址，因此會賦予這些符號一個暫時的位址，並且記錄在符號表(symbol table)和重定位表(relocation table)中。

鏈接器會根據這些表進行重定位，將暫時的位址替換為最終的實際位址，完成可執行檔案的生成。




# 作業系統
- RTOS基礎知識 : https://www.freertos.org/zh-cn-cmn-s/Documentation/01-FreeRTOS-quick-start/01-Beginners-guide/01-RTOS-fundamentals
- 作業系統 : https://hackmd.io/@Chang-Chia-Chi/OS-CH3
- C語言編譯流程 : https://hackmd.io/@zoanana990/S1RySgR3A
- Context Switch範例 : https://github.com/jserv/mini-arm-os/tree/master/02-ContextSwitch-1

搞懂
1. 中斷是什麼
2. context switch 是什麼
3. startup.c 在做什麼
4. linker.ld 是什麼