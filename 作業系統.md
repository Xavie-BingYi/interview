# 參考資料
- **RTOS基礎知識 :** https://www.freertos.org/zh-cn-cmn-s/Documentation/01-FreeRTOS-quick-start/01-Beginners-guide/01-RTOS-fundamentals
- **作業系統 :** https://hackmd.io/@Chang-Chia-Chi/OS-CH3

# 目錄
1. [堆疊（Stack）](#一堆疊stack)
2. [暫存器（Registers）](#二暫存器registers)
3. [堆疊指標（Stack Pointer, SP）](#三堆疊指標stack-pointer-sp)
4. [堆疊範例：任務初始化與切換](#四堆疊範例任務初始化與切換)
5. [線程（Thread）](#五線程thread)
6. [輪詢工作（Polling Task）](#六輪詢工作polling-task)
7. [上下文切換（Context Switch）](#七上下文切換context-switch)
8. [Context Switch範例](#八context-switch範例)

# 一、堆疊（Stack）
堆疊是一種數據結構，用於管理和儲存程式的執行資訊。它遵循「後進先出」（LIFO，Last In First Out）的原則，最後放入堆疊的數據會最先被取出。可以想像成一堆盤子，最上面的盤子是最容易被取走的。堆疊通常位於 CPU 使用的 RAM（隨機存取記憶體）中的一個區域，當程式執行時，堆疊用來儲存函式呼叫的返回地址、局部變數及其他執行上下文信息。

## 1. 堆疊的特性：
1. 位置：堆疊的起始位置在 RAM 的某個地址，具體取決於系統設計。
2. 動態大小：堆疊的大小隨著函式的呼叫深度變化，但有最大限制，超過後會導致堆疊溢出（stack overflow）。
3. 後進先出（LIFO）：堆疊遵循後進先出原則，即最後放入的數據最先被取出。

## 2. 堆疊的主要用途
### 2.1 函式呼叫與返回
- 當一個函式被呼叫時，堆疊會保存當前程式的執行位置（返回地址）。
- 返回地址是儲存在鏈接寄存器（LR, Link Register）中的值，它保存了當前程序計數器（PC, Program Counter）的值，該值指向下一條要執行的指令位址。每一條指令都存放在記憶體的特定位址中，而 PC 負責追蹤程式中的下一條指令的位置。
### 2.2 返回地址與局部變數
- 返回地址（LR，Link Register）和函式中的局部變數的值會一起被放在堆疊的最上層，當函式被呼叫時，這些資料會被推入堆疊。
- 可以想像堆疊是一疊盤子，當函式執行完畢後，可以像取走最上面的盤子一樣，從堆疊中提取出返回地址和局部變數的值。然後根據返回地址繼續執行程式，回到呼叫該函式的位置。
### 2.3 局部變數儲存
- 函式中的局部變數會被存放在堆疊中，當函式結束時，這些變數會自動釋放。
### 2.4 上下文切換（Context Switch）
- 在多任務系統中，堆疊用來保存每個任務的執行狀態，以便在切換到另一個任務時能夠恢復之前的狀態。

## 3. 堆疊操作
- Push（推入）：將數據放入堆疊頂部，並更新堆疊指標。
- Pop（彈出）：從堆疊頂部取出數據並返回給使用者，並更新堆疊指標。
- Peek（查看）：查看堆疊最上方的元素，但不移除該元素，堆疊指標不變。
- Size（大小）：返回堆疊中元素的數量。
- IsEmpty（是否為空）：檢查堆疊是否為空。

## 4. 堆疊在作業系統中的角色
- 函式執行與任務切換：每當一個任務被啟動或一個函式被呼叫，系統會分配一個堆疊來儲存當前執行狀態，包括返回地址、局部變數等。
- 上下文切換：作業系統會保存當前任務的堆疊狀態，切換到其他任務後再恢復之前的堆疊狀態，以確保程式正確執行。

# 二、暫存器（Registers）
暫存器是處理器內部的高速存儲空間，負責保存運算中的臨時數據。其存取速度遠快於 RAM，但數量有限。暫存器由 CPU 直接管理，而 RAM 則是用於儲存執行中的程式和數據。

暫存器屬於處理器的核心組件，設計和數量依不同處理器架構而定，如 ARM、x86。除了暫存器。

## 1. 暫存器的作用
- 存放運算數據：處理器會將當前運算或操作所需的數據暫時存放在暫存器中。
- 處理器控制：某些暫存器負責控制程式執行，例如堆疊指標暫存器（SP, Stack Pointer）。

## 2. 常見的 ARM 暫存器
### 2.1 通用暫存器（以 ARMv8 為例）
- x0 - x31：ARMv8 及後續版本的通用暫存器。
	- x0 - x7：通常用於函式的參數傳遞和返回值。
	- x8：通常用作臨時暫存器，且有時會用作函式返回地址的存放。
	- x9 - x12：可視為臨時暫存器，通常用於儲存局部變數或中間計算結果。
    - x13：專門用作堆疊指標（SP）。
    - x14：通常用作返回地址寄存器（LR），在某些特殊情況下可用作其他用途。
    - x15：主要用作程序計數器（PC）。
	- x16 - x29：通常用作臨時暫存器。
    - x30：專門用作返回地址暫存器（LR，Link Register）。
#### 補充：
Cortex-M4 基於 ARMv7-M 架構。ARMv8 引入了 64 位元支援，像 Cortex-M33 和 Cortex-M23 這些處理器則基於 ARMv8-M 架構。
### 2.2 特殊用途暫存器
- x29 (FP, Frame Pointer)：用於指向當前函式的堆疊框架，有助於局部變數的管理。
- x31 (SP, Stack Pointer)：指向當前堆疊頂部的地址，負責堆疊的推入和推出操作。
### 2.3 r 系列暫存器（ARMv7 及以前版本）
- r0 - r15：ARMv7 及以前版本的通用暫存器，其中：
	- r13 (SP, Stack Pointer)：指向堆疊的頂部。
	- r14 (LR, Link Register)：存放函式返回地址。
### 2.4 特殊暫存器
#### 1. SP（堆疊指標，Stack Pointer）
SP 是用來指向堆疊頂部的暫存器。
- 當資料被「推入」（Push）堆疊時，SP 會更新指向堆疊中的新位置。
- 當資料被「彈出」（Pop）堆疊時，SP 會指向下方的資料。

具體來說，SP 是指向記憶體中堆疊頂端的位置，這個位置位於 RAM 中。隨著資料被加入或移除，SP 的值會隨之改變。
#### 2. PC（程序計數器，Program Counter）
PC 是指向當前執行的指令位址的暫存器。程式中的每一條指令都存放在記憶體中的某個位址，PC 記錄著程式當前要從哪個位址讀取指令，並執行它。這不僅限於主程式，也包含所有子函數。當主程式或函數執行時，PC 負責追蹤程式進行的步驟，確保處理器從正確的位址提取指令。
- 每當執行完一條指令後，PC 會自動更新，指向下一條要執行的指令位址。這樣程式才會按照正確的順序來執行。
#### 3. LR（返回地址寄存器，Link Register）
LR 是用來保存當前的返回地址。當主程式呼叫一個函數時，程序需要知道這個函數執行完畢後應該返回到哪裡，這個返回地址就會存放在 LR 中。
- 當函數被呼叫時，PC（程序計數器）的值會存入 LR，這個值表示主程式當前執行到的位置，讓函數執行完畢後可以正確返回到這裡繼續執行主程式。
- 當函數結束時，LR 的值會被載入 PC，使程式跳回到函數被呼叫之前的位置。
#### 具體例子
函數呼叫時：
1. 新函數的局部變數和返回地址會被推入堆疊中，SP 會指向新加入的資料。
2. LR 保存當前的返回地址，這是主程式中的位置，用來指示未來函數返回後，該從哪裡繼續執行。

函數返回時：
1. 當函數執行完畢，堆疊頂部的資料會被彈出，SP 會回到先前的狀態。
2. LR 提供返回的指令位址，這個位址會載入 PC，讓程式回到主程式並繼續執行。
### 2.5 狀態暫存器
- CPSR（Current Program Status Register）：包含處理器的狀態信息，如中斷使能位、運算結果標誌位等。
- SPSR（Saved Program Status Register）：在中斷或異常發生時，保存 CPSR 的狀態。
### 2.6 浮點與 SIMD 暫存器
- S0 到 S31：用於單精度浮點運算。
- D0 到 D31：用於雙精度浮點運算。
- Q0 到 Q15：用於 SIMD 和 NEON 指令集，處理多媒體數據。
### 2.7 控制暫存器
- MRC/MCR 指令使用的控制暫存器：用於系統控制和配置，例如協處理器的配置。
### 2.8 系統暫存器
- 用於處理器的配置和狀態控制，如中斷控制和記憶體管理。

不同的 ARM 架構版本（如 ARMv7、ARMv8）會有一些差異，但這些是主要的暫存器類別。

## 3. 通用暫存器與其功能介紹
### ARMv7 架構中的 r 系列暫存器 對應 ARMv8 架構中的 x 系列暫存器 的功能對應表：
| ARMv7 r 系列暫存器 | ARMv8 x 系列暫存器 | 功能描述          |
|---------------------|---------------------|-------------------|
| r0                  | x0                  | 函式參數傳遞和返回值 |
| r1                  | x1                  | 函式參數傳遞        |
| r2                  | x2                  | 函式參數傳遞        |
| r3                  | x3                  | 函式參數傳遞        |
| r4                  | x4                  | 函式參數傳遞        |
| r5                  | x5                  | 函式參數傳遞        |
| r6                  | x6                  | 函式參數傳遞        |
| r7                  | x7                  | 函式參數傳遞        |
| r8                  | x8                  | 臨時用途             |
| r9                  | x9                  | 臨時用途             |
| r10                 | x10                 | 臨時用途             |
| r11                 | x11                 | 臨時用途             |
| r12                 | x12                 | 臨時用途（ip）      |
| r13 (sp)            | x13 (sp)            | 堆疊指標             |
| r14 (lr)            | x30 (lr)            | 返回地址             |
| r15 (pc)            | x15 (pc)            | 當前指令地址         |

### 3.1 參數傳遞與返回值
在 ARM 架構中，前幾個通用暫存器（如 r0 至 r3 或 x0 至 x3）專門用於函式的參數傳遞。這樣的設計提高了函式呼叫的效率，因為可以減少對記憶體的訪問。返回值通常通過 r0（或 x0）傳遞，這樣函式的使用者可以直接獲取結果。
#### 範例：函式參數傳遞與返回值
這段程式碼展示了如何使用通用暫存器來傳遞函式參數和返回值：
```assembly
.global main

main:
    MOV x0, #5          // 將 5 放入 x0 (第一個參數)
    MOV x1, #3          // 將 3 放入 x1 (第二個參數)
    BL add_numbers       // 呼叫 add_numbers 函式
    // x0 現在包含返回值
    // 可在此處進行其他操作，最後結束程式

add_numbers:
    ADD x0, x0, x1      // 將 x0 和 x1 相加，結果存回 x0
    RET                  // 返回
```
`add_numbers` 函式的設計是將結果存回 `x0`，這使得 `x0` 成為函式的返回值。這是因為在 ARM 架構中，通常約定使用 `x0` 作為返回值的暫存器。因此，無論 `add_numbers` 的運算如何，呼叫者都可以從 `x0` 中獲取結果。

### 3.2 臨時用途
暫存器 r8 至 r11（或 x8 至 x11）被用作臨時用途，這些暫存器在函式執行期間可以存放不需持久化的數據，從而提高運算效率。由於這些暫存器不需要保存其值，因此在函式調用時可被自由使用。
#### 範例：使用臨時用途暫存器
這段程式碼展示了如何使用臨時用途暫存器來存放中間計算結果：
```assembly
.global main

main:
    MOV x0, #10         // 將 10 放入 x0
    MOV x1, #20         // 將 20 放入 x1
    MUL x2, x0, x1      // 使用 x2 (臨時暫存器) 存放乘法結果
    // 此時 x2 包含 200 (10 * 20)
    // 進一步的運算可以使用 x2

    // 最後結束程式
```
### 3.3 臨時用途（ip）
在 ARM 架構中，ip（內部程序呼叫暫存器）通常用於存放在函式呼叫過程中需要的臨時數據，尤其是中間計算結果或返回地址。以下是與 3.2 不同的範例，展示如何使用 ip 暫存器：
#### 範例：使用 ip 暫存器
這段程式碼展示了如何利用 ip 暫存器來存放中間計算結果，以及在函式呼叫過程中保留返回地址：
```assembly
.global main

main:
    MOV x0, #5          // 將 5 放入 x0 (第一個參數)
    MOV x1, #3          // 將 3 放入 x1 (第二個參數)
    
    BL multiply         // 呼叫 multiply 函式

    // 在此處進行其他操作
    // 最後結束程式

multiply:
    MOV x2, x0          // 將 x0 的值存入 x2
    MOV x3, x1          // 將 x1 的值存入 x3
    MUL x2, x2, x3      // x2 = x0 * x1 (計算結果存回 x2)

    // 使用 ip 暫存器來存放一個臨時值
    MOV x12, x2         // 將計算結果暫存到 x12 (ip)
    
    // 繼續其他運算，例如加上一個常數
    ADD x0, x12, #1     // 將 x12 的結果加 1，結果存回 x0 (返回值)

    RET                  // 返回
```
#### 舉例與解釋
ip 暫存器的靈活性在於提供穩定的臨時存儲空間。在執行某個函式時，x0 到 x5 可能隨著參數傳遞和計算而改變。如果在函式中使用 ip 暫存器來存放重要的中間結果，即使其他函式修改了 x0 到 x5 的值，仍然可以依賴 ip 暫存器中的數據，從而減少資料損失或覆蓋的風險。

ip 暫存器的使用方式使其成為管理函式之間數據流的一種靈活工具，特別是在處理複雜計算或多重函式調用的情境中。

### 3.4 堆疊指標
r13（或 x13）是堆疊指標（SP），指向當前堆疊的頂部。堆疊是函式調用過程中存儲局部變數和返回地址的重要結構。堆疊指標的管理對於確保數據的正確性和函式的正常返回至關重要。
#### 範例：堆疊指標的使用
這段程式碼展示了如何使用堆疊指標來儲存局部變數：
```assembly
.global main

main:
    SUB sp, sp, #16     // 為局部變數分配 16 字節的堆疊空間
    STR x0, [sp]        // 將 x0 的值存放到堆疊
    // 在這裡進行其他操作
    LDR x1, [sp]        // 從堆疊載入值到 x1
    ADD sp, sp, #16     // 釋放堆疊空間
    // 最後結束程式
```
### 3.5 返回地址
r14（或 x14）是鏈接寄存器（LR），用於存放函式返回地址。在函式被呼叫時，當前指令的地址會存放在 LR 中，以便在函式執行完畢後能夠正確返回至呼叫者的執行點。LR 是控制程序流的重要組件。
#### 範例：返回地址的使用
這段程式碼展示了如何使用鏈接寄存器來控制返回地址：
```assembly
.global main

main:
    MOV x0, #1          // 將 1 放入 x0
    BL foo              // 呼叫 foo 函式
    // 返回到此處

foo:
    ADD x0, x0, #2      // 將 x0 的值加 2
    RET                  // 返回到 main 的下一行
```
### 3.6 當前指令地址
r15（或 x15）是程序計數器（PC），指向當前執行的指令地址。程序計數器的值隨著指令的執行而不斷更新，它是實現程序流程控制的核心。對於任何程式的正確執行，PC 的準確管理至關重要。
#### 範例：當前指令地址的示範
這段程式碼顯示了如何使用程序計數器（PC）：
```assembly
.global main

main:
    MOV x0, #5
    MOV x1, #10
    ADD x2, x0, x1      // x2 現在是 15
    // PC 的值會自動更新至下一指令
```

## 4. 暫存器與 Caller/Callee 保存機制
### ARM 架構中的通用暫存器
在 ARM 架構下，暫存器是運行程式時極為重要的資源。以下是一些重要的暫存器及其功能：
| 暫存器 | 名稱                  | 功能說明 |
|--------|-----------------------|----------|
| r0     | 函數參數、返回值       | 用於存放函數的第 1 個參數或返回值 |
| r1     | 函數參數               | 用於存放函數的第 2 個參數 |
| r2     | 函數參數               | 用於存放函數的第 3 個參數 |
| r3     | 函數參數               | 用於存放函數的第 4 個參數 |
| r4-r11 | Callee-saved 暫存器    | 這些暫存器負責保存局部變數，Callee 在函式執行完畢時必須恢復它們 |
| r12    | 臨時暫存器             | 用於存放臨時數據 |
| r13    | 堆疊指標（SP）         | 指向堆疊的頂部，用來管理函數呼叫過程中的資料 |
| r14    | 返回地址（LR）         | 保存函數返回的地址，當函數執行完畢後會跳回這個位置 |
| r15    | 程序計數器（PC）       | 指向當前指令的記憶體地址，控制程式流程 |

在較新的 ARMv8 架構中，通用暫存器 x0 到 x31 取代了傳統的 r0 到 r15，提供了 64 位元的運算能力。x0 到 x7 通常用於函數的參數傳遞和返回值，x30 則是用作返回地址的暫存器。

### Caller 和 Callee 的暫存器保存機制
當函數呼叫發生時，呼叫者（Caller）與被呼叫者（Callee）會有不同的暫存器保存責任，以確保在函數之間交換資料時不會丟失重要資訊。
1. **Caller-saved 暫存器**：r0 到 r3 用來傳遞函數參數和返回值，Caller 在呼叫另一個函數前需要保存它們，以防它們被 Callee 修改。
2. **Callee-saved 暫存器**：r4 到 r11 為 Callee-saved 暫存器，這意味著當 Callee 修改這些暫存器時，必須在函數返回前恢復它們的原始值，保護 Caller 的資料。

這個機制的作用在於維持函數之間的資料一致性，讓不同的函數能安全地呼叫彼此而不互相影響。

### 程式碼示例
以下是一個簡單的示例，顯示了如何在函數呼叫中使用暫存器：
```c
void functionA(int a, int b) {
    int result = a + b;  // 使用 r0 和 r1 來傳遞參數
    // result 存放在堆疊中
}

void main() {
    functionA(5, 10);  // r0 = 5, r1 = 10
}
```
這段程式碼中，`functionA` 函數使用 r0 和 r1 接收參數，並進行運算。這樣的設計確保了在函數執行過程中資料的一致性與正確性。

### x 暫存器與 Caller/Callee 的關係
在 ARMv8 架構中，x0 到 x7 是典型的 Caller-saved 暫存器，主要用於傳遞參數和接收返回值。x19 到 x29 則為 Callee-saved 暫存器，它們的值在函數執行時會被保留且在返回前恢復。

這種設計可以讓程式在執行遞迴或多次函數呼叫時保持暫存器的穩定狀態，並確保 Caller 的資料不會意外丟失。

## 5. 暫存器與堆疊的關係
由於暫存器數量有限，當函式嵌套或遞迴呼叫時，處理器會將暫存器中的資料保存到堆疊中，以確保之後能夠正確恢復。堆疊的存在允許處理器在運行複雜的程式時，靈活地管理數據和函式狀態。

### 範例：Fib 函式的遞迴呼叫
```c
int fib(int n) {
    return n < 2 ? 1 : fib(n-1) + fib(n-2);
}

int main() {
    printf("%d\n", fib(3));
}
```
### Fib 遞迴的執行流程
當呼叫 `fib(3)` 時：
### 1. 將變數 `3` 存到暫存器：
- `3` 會先被存到暫存器中（例如 x1 暫存器）。
### 2. 遞迴呼叫 `fib(3-1)` 和 `fib(3-2)`：
- 處理器接著執行遞迴呼叫，先進入 `fib(2)`，然後是 `fib(1)`。
### 3. 堆疊保存：
- 當函式進行遞迴呼叫時，原本存放在 x1 暫存器中的值（即 `3`）會被暫時保存到堆疊中，等到需要恢復 `fib(3)` 時，會從堆疊中取回該數值。

# 三、堆疊指標（Stack Pointer, SP）
堆疊指標是用來指示堆疊區域頂部的記憶體地址。當一個函式被呼叫時，堆疊指標會指向堆疊的最上方，並在函式的執行過程中隨著局部變數和其他資料的推入或推出而改變。

## 堆疊的工作原理
### 1. 堆疊的分配： 
在嵌入式系統中，堆疊通常是從一個高位地址開始，向下增長。例如，假設堆疊的起始地址是 `0x1000`，這意味著堆疊的最上方在 `0x1000`。
### 2. 推入資料： 
當你呼叫一個函式時，該函式的返回地址、參數和局部變數會被推入堆疊。這時，堆疊指標會向下移動。例如，假設我們推入了一個 4 字節的整數，那麼堆疊指標會更新為 `0x0FFC`：
- 初始堆疊指標：`0x1000`
- 推入 4 字節後：`0x1000 - 0x0004 = 0x0FFC`
### 3. 推出資料： 
當函式執行結束並返回時，堆疊指標會更新回去，釋放已推入的資料。例如，如果函式結束後，堆疊指標將再次更新為 `0x1000`。

## 數值的來源
- 堆疊大小： 堆疊的大小通常由微控制器的內部設置決定。對於 STM32 這樣的微控制器，開發者可以在專案設置中指定堆疊的大小，這會影響堆疊的起始地址。
- 堆疊指標的初始值： 堆疊指標的初始值是在程式啟動時由啟動程式設定的，通常會設定為堆疊的起始地址。

## 範例：Fib 函式遞迴中的堆疊操作
以 `fib(3)` 的遞迴呼叫為例：
### 1. 儲存 x1 暫存器中的值：
- 呼叫 `fib(3)` 時，值 `3` 會先存入暫存器 x1。
### 2. 進入 `fib(2)` 的遞迴：
- 因為接下來要處理遞迴呼叫，處理器會將 x1 中的值（即 3）保存到堆疊記憶體位置（例如 0x1000）。
### 3. 更新堆疊指標：
- 堆疊指標 SP 會從 0x1000 向下移動，更新為 0x0ffc，為下一個可能存入的數據預留空間。

# 四、堆疊範例：任務初始化與切換
```c
void usertask(void)
{
	usart_printf("User Task #1\r\n");
	while (1); /* Never terminate the task */
}

int main(void)
{	
    /* 初始化任務的堆疊 (stack)
	 * r4, r5, r6, r7, r8, r9, r10, r11, lr */
	unsigned int usertask_stack[256];
	unsigned int *usertask_stack_start = usertask_stack + 256 - 16;
	usertask_stack_start[8] = (unsigned int) &usertask;

    /* 初始化 USART 並顯示訊息 */
	usart_init();
	usart_printf("OS Starting...\r\n");

    /* 啟動 usertask 任務 */
	activate(usertask_stack_start);

	while(1){
		/* 主程式無限迴圈，保持系統運行 */
	}

	for(;;);
}
```
## 1. `usertask(void)` 函數
- 使用 `usart_printf` 打印出 `"User Task #1"`，用於顯示任務的執行狀況。
- 進入一個無限迴圈 `while(1)`;，確保任務不會終止，保持持續運行。

## 2. `main` 函數
### 2.1 初始化任務堆疊
- 分配堆疊空間：`unsigned int usertask_stack[256];`創建了 256 個單位的陣列作為該任務的堆疊空間。
- 設置堆疊指標：`usertask_stack_start = usertask_stack + 256 - 16;`堆疊從高位址向低位址生長，指標設置到陣列尾端，並預留 16 個位置，用來存放處理器的暫存器值（`r4` 到 `r11` 等暫存器）。
- 設置函式起點：`usertask_stack_start[8] = (unsigned int) &usertask;` 這行程式碼設置堆疊中的第 8 個位置為 `usertask` 函數的位址，這樣啟動任務時處理器會從該函式開始執行。
### 2.2 初始化 USART 並顯示訊息
- 初始化 USART：`usart_init();`設置串列通訊。
- 顯示系統啟動訊息：`usart_printf("OS Starting...\r\n");`告知系統已經開始運行，顯示訊息 `"OS Starting..."`。
### 2.3 啟動任務
- 啟動新任務：`activate(usertask_stack_start);` 開始執行 `usertask` 任務。

## 3. 程式運行流程總結
### 1. 初始化任務堆疊：
為任務分配堆疊空間，準備好存放暫存器值，並設置任務的執行起點。
### 2. 初始化 USART 並顯示訊息：
通過串列通訊 (USART) 顯示系統啟動訊息 `"OS Starting..."`，通常這個步驟是用來在系統啟動時進行除錯或提示。
### 3. 啟動任務：
透過 `activate` 函數啟動 `usertask` 任務，該任務會打印 `"User Task #1"`，然後進入無限迴圈，持續運行，不會結束。
### 4. 主程式不會進入自身迴圈：
由於 `usertask` 任務的無限迴圈將持續佔用執行權，因此程式不會再返回 `main` 函數，也不會執行 `main` 函數中的無限迴圈。

# 五、線程（Thread）
Thread（線程），有時稱為輕量級進程（Lightweight Process），是 CPU 利用的一個基本單位。它可以理解為一個 program（程序）中的執行路徑。傳統的 process（進程）通常包含多個線程，每個線程可以同時執行不同的任務。

## Process 與 Thread 的關係
當啟動一個 program 時，作業系統會將該程序的內容載入到 RAM 中，並將其轉換為一個 process。這個 process 的結構包含以下部分，這些部分分布於 RAM 中：

- Code：放置於 text 段，包含程序執行的指令。
- Data：包括全域變數，存放於 data 段。
- Heap：用於存放動態分配的變數。
- Stack：用於存放局部變數及函數返回地址。

此外，該 process 也涉及由 CPU 中的 registers（寄存器）進行快速數據操作，以及由作業系統管理的 files（檔案），這些檔案描述符通常由作業系統的內部結構進行管理。

另一方面，thread 是在 process 執行過程中所建立的輕量級程序。在多個 threads 同時執行時，所有 threads 會共享同一個 process 的 code、data 及 files，而每一個 thread 會擁有自己的執行上下文，包括 registers、stack 以及 program counter（程序計數器）。

## Thread 在嵌入式系統中的角色
在 嵌入式系統 中，Thread 扮演著重要的角色，特別是在資源有限且需要同時執行多個任務的情況下。例如，在嵌入式設備中，一個線程可以用來處理按鍵輸入，另一個線程可以負責顯示屏更新，這些線程可以互相協作並行工作。

### 主要功能：
- 資源共享：同一進程內的所有線程可以共享資源，如代碼區段、數據區段、開啟的文件和信號。
- 獨立的運行上下文：每個線程有自己獨立的執行環境，包括線程 ID、程式計數器（PC）、寄存器集合、堆疊等。

### Thread 的實現方式
在嵌入式系統中，線程的實現可以通過以下方式：

1. 操作系統支持：許多嵌入式系統都有支援線程的操作系統，如 FreeRTOS、Zephyr 等。這些 RTOS 通常提供線程管理功能，包括線程創建、刪除、優先級設定等。
2. 內核調度器：系統會有一個內核調度器負責在線程之間切換執行。這個過程稱為上下文切換（Context Switch），當一個線程被暫停，另一個線程開始執行時，系統會保存當前線程的上下文，並加載下一個線程的上下文。
3. 協程或事件驅動架構：在沒有 RTOS 的情況下，也可以通過事件驅動的方式實現類似線程的功能，這種方式更適合資源非常有限的小型嵌入式系統。

## Thread 的應用場景
- 多任務處理：在嵌入式系統中，Thread 可以用來實現多任務並行處理。例如，網絡設備中的一個線程負責處理通信，另一個線程則監控傳感器數據。
- 提高效率：通過使用多個線程，系統可以更有效地利用 CPU，實現更快的響應時間和更高的吞吐量。
- 即時控制：嵌入式系統通常需要即時響應環境變化，Thread 可以幫助系統同時處理多個高優先級的事件。

## 總結
Thread 是嵌入式系統中的重要元素，它允許在同一個程序中執行多個任務，並且可以有效利用系統資源。每個 Thread 都有自己獨立的執行環境（如程序計數器和寄存器集合），但它們共享進程的資源（如代碼和數據段），這使得線程成為處理多任務、提高系統性能的有效工具。

# 六、輪詢工作（Polling Task）
## 什麼是 Polling Task?
在嵌入式系統中，Polling Task 是一種操作模式，與 中斷（Interrupt） 類似，主要用來定期檢查設備或資源的狀態。常見應用包括：
- 檢查按鍵是否被按下
- 監控傳感器的數據變化

## Polling Task 的運作方式
Polling Task 會根據設定的時間間隔持續檢查特定設備或資源的狀態。由於這種檢查是同步執行的，如果檢查過程過長，會導致主線程無法執行其他任務，可能影響系統的整體反應速度。

## Polling Task 與 Thread 的關係
為了解決主線程被鎖住的問題，可以將不同的 Polling Task 分配到多個 Thread 中執行，這樣的設計帶來以下幾個優勢：

- 並行處理：不同的 Thread 可以獨立監控不同的設備或資源，防止主線程被單一任務佔用。例如：
    - 一個 Thread 專門監控按鍵
    - 另一個 Thread 檢查傳感器
- 資源共享：這些 Thread 可以共享同一個 Process 的資源，不需要額外的數據傳輸機制來進行資訊交換，提升運作效率。
- 獨立運行上下文：每個 Thread 擁有自己的執行上下文，在進行 上下文切換（Context Switch）時，系統可以快速保存和恢復狀態，進一步提升反應速度。

## Polling Task 與process的關係
Polling Task 是 Process 內的一個邏輯任務，由特定的 Thread 負責執行。它不對應特定的記憶體區域，而是依賴 Thread 的 堆疊（Stack） 來保存執行上下文（如寄存器和堆疊指標）。

每當 Polling Task 被調度執行時，它會使用該 Thread 的上下文來進行檢查操作，這樣的設計可以避免主 Thread 被長時間的 Polling 操作鎖住，提升整體系統的響應效率。

## 設計優勢
將 Polling Task 分配到多個 Thread 中運行，帶來以下好處：
- 提升系統反應速度：避免主線程因長時間的 Polling 操作而被鎖住。
- 高效資源使用：Thread 可以共享資源，並保持各自的執行上下文，方便進行上下文切換。
- 靈活性高：不同 Thread 可以同時執行多個 Polling Task，實現並行處理，減少單一任務對系統的影響。

## 觸發 GPIO 按鍵對應函數之方法：Polling Task 與 Interrupt 的差異
在驅動程式中，Polling Task 和 Interrupt 是兩種處理硬體事件的常用方法。這兩者之間的選擇取決於應用場景的需求、系統資源以及效能要求。以下是兩者的詳細比較與分析。

### Polling Task
#### 運作方式：
Polling Task 是主動檢查硬體狀態的方式。系統會定期檢查設備是否發生事件，這通常是在一個 `while` 迴圈中，不斷監測硬體狀態，如檢查按鍵是否被按下。
#### 優點：
1. 簡單易實現：寫法直接，無需處理多餘的同步或共享資源問題，開發與除錯難度較低，只需在循環中定期檢查設備狀態。
2. 可預測性強：程式的執行順序和時間間隔是固定的，適合對時間敏感的應用。
3. 較少同步問題：不需要處理複雜的中斷同步和資源共享問題。
#### 缺點：
1. 資源浪費：即使沒有事件發生，程式仍需不斷執行查詢，消耗 CPU 資源，影響系統性能。
2. 延遲問題：如果事件發生在兩次查詢之間，程式需要等待下一次查詢才會處理該事件，導致反應延遲。
3. 不適合高負載場景：在處理大量硬體事件時，Polling 的方式容易出現性能瓶頸，甚至可能錯過事件。
#### Polling Task 與 Thread 的關係
Polling Task 可以執行在單一或多個 Thread 上。多 Thread 可以分別監控不同設備或資源，以達到並行處理的效果。例如一個 Thread 負責按鍵監控，另一個負責傳感器狀態檢查。這樣能避免主線程被長時間的 Polling 鎖住，提升系統的響應效率。

### Interrupt
#### 運作方式：
Interrupt 是被動的事件觸發方式。當硬體發生事件時，會向 CPU 發送中斷信號，CPU 暫停當前的任務，立即執行對應的中斷處理程式（ISR，Interrupt Service Routine）。
#### 優點:
1. 高效利用資源：只有事件發生時才需要 CPU 介入，減少了無效的查詢，節省系統資源
2. 即時響應：中斷一旦發生，系統能立即處理，反應速度較快，適合即時性要求高的場景。
#### 缺點:
1. 較高實現難度：需要處理中斷優先級、同步與共享資源等問題，開發較為複雜。
2. 潛在的穩定性問題：過多的中斷可能會打斷正常的任務執行，影響系統的穩定性。

### 差異與總結
Polling Task 和 Interrupt 之間的主要差異在於處理事件的方式。Polling Task 是主動查詢硬體狀態，適合低頻率、不需即時反應的任務。Interrupt 則是被動響應硬體事件，能有效地處理頻繁且即時的事件。

- Polling Task 實現簡單，但消耗資源，反應較慢。
- Interrupt 即時響應高效，但需要處理複雜的同步與優先級問題。

#### 何時選擇 Polling 或 Interrupt
- 使用 Polling：適合事件發生頻率低或不需要即時響應的應用，如按鈕按下的狀態查詢或簡單的設備監控。
- 使用 Interrupt：適合需要即時響應的場景，如通訊協議中資料接收、計時器中斷，或按鍵反應速度要求較高的應用。

# 七、上下文切換（Context Switch）
## 定義
上下文切換是當 CPU 在不同進程之間切換執行時所需的過程。由於 CPU 一次只能執行一個進程，當需要將控制權轉移給另一個進程時，必須保存當前進程的狀態，並載入新進程的狀態。這一過程對於操作系統來說非常重要，因為它能讓多個進程共享 CPU 資源。

## 流程
### 1. 執行 P0
CPU 開始執行第一個進程 P0，該進程正在進行其任務。
### 2. P0 被打斷
- 當時間片到達（即 P0 的執行時間用完）或出現外部中斷（如用戶輸入），P0 可能會被暫停。
- CPU 會進入閒置（idle）狀態，等待進一步指令。
### 3. 進行上下文切換
- 保存當前狀態：系統將 P0 的狀態保存到進程控制塊（PCB）中。PCB 包含了進程的所有信息，包括暫存器值、進程狀態、優先級等。
- 讀取新進程狀態：系統讀取 P1 的 PCB，以獲取它的狀態信息，了解 P1 暫停時的執行狀況。
- 完成上下文切換：CPU 載入 P1 的狀態，恢復 P1 的暫存器值及其他必要的信息。
### 4. 執行 P1
CPU 開始執行新進程 P1，接著 P1 會在它之前被暫停的地方繼續執行。

## 上下文切換的開銷
在整個上下文切換的過程中，CPU 並沒有實際執行任何業務邏輯的指令，因此這段時間被視為開銷（overhead），會浪費一些 CPU 資源。儘管如此，為了實現 CPU 共享和時間共享，上下文切換是不可避免的。

## 優化上下文切換的方式
為了減少上下文切換的開銷，可以採取以下方法：
- 提高內存速度：使用更快的記憶體技術，減少數據存取延遲，讓進程更快讀取或寫入所需數據。
- 減少寄存器數量：設計上可以減少使用的寄存器數量，以降低上下文切換時的存取次數。
- 合併加載與保存 PCB 的指令：透過將多個指令合併為一個操作，減少指令執行次數，提高效率。
- 硬體支援：使用多組寄存器來快速切換不同進程的狀態，減少頻繁訪問內存的需求。

## 總結
上下文切換是操作系統的核心功能之一，使 CPU 能夠在多個進程之間有效切換。透過合理設計和優化，可以減少上下文切換的開銷，提高系統性能。理解上下文切換的過程及其重要性，有助於初學者更好地掌握操作系統的運作原理。

# 八、Context Switch範例
**範例程式**：https://github.com/jserv/mini-arm-os/tree/master/02-ContextSwitch-1

這段 ARM 彙編語言的程式碼，實現了一個名為 `activate` 的函式，目的是切換執行環境，將系統狀態從內核模式切換到用戶模式：
```asm
.thumb
.syntax unified

.global activate
activate:
	/* save kernel state */
	mrs ip, psr
	push {r4, r5, r6, r7, r8, r9, r10, r11, ip, lr}

	/* switch to process stack */
	msr psp, r0
	mov r0, #3
	msr control, r0

	/* load user state */
	pop {r4, r5, r6, r7, r8, r9, r10, r11, lr}

	/* jump to user task */
	bx lr
```
## 1. `.thumb` 和 `.syntax unified`
- 傳統 ARM 指令集中的每個指令都是 32 位元，而 Thumb 指令集中的指令則是 16 位元的，這使得程式碼更緊湊，能夠在有限的記憶體中儲存更多的指令，多為嵌入式系統使用。
- `.thumb` 指定程式碼將以 ARM 的 Thumb 指令集運行，這是一種較精簡的指令集。

    一般來說，標準 ARM 編譯器（如 `arm-none-eabi-gcc`）都自帶對 Thumb 指令集的支援，所以在編譯和鏈接的時候不需要額外包含特定的庫。只要你的編譯器支持 ARM 的 Thumb 指令集，就可以直接使用。
- `.syntax unified` 表示使用統一的彙編語法，允許 ARM 和 Thumb 指令混合使用。

## 2. `.global activate`
- 宣告 `activate` 函式為全域，讓其他文件或程式碼能引用它。

## 3. `activate:`
- 這行代表一個標籤，定義了函式的入口點，使其他程式能跳轉或呼叫此函式。

## 4. `mrs ip, psr`
- `ip`：表示 **"Intra-Procedure-call Scratch Register"**，即 **r12 暫存器**，它是一個可以在函式內部臨時使用的暫存器。
- `mrs` 指令用來從特定的暫存器中讀取數據。這裡是將 **程序狀態暫存器 (PSR)** 的內容存入暫存器 `ip`（即 r12）中，這是為了保存當前的 CPU 狀態，以便後續可能需要恢復這些資訊。PSR 儲存著 CPU 當前的狀態，如旗標 (flags) 和模式資訊。

## 5. `push {r4, r5, r6, r7, r8, r9, r10, r11, ip, lr}`
- `push` **指令** 的作用就是將指定暫存器的內容「推入堆疊」，這意味著把暫存器中當前的數據保存起來，以便稍後可以從堆疊中取回（恢復）；換句話說，**push** 就是為了「暫時保存」，稍後用 **pop** 來「恢復」這些內容，確保切換時不會丟失重要數據。
- 這行的目的是在進行**上下文切換 (context switch)** 時，先保存當前程式的狀態，這樣等到回到這個程式時，能恢復到當前狀態繼續執行。

- r4 到 r11：這些是 ARM 處理器中的通用暫存器，可能儲存了執行中的任務或計算的數據。
- `ip` (r12)：是個臨時暫存器，用來存儲 psr 的內容（當前 CPU 狀態）。
- `lr` (link register)：儲存的是返回地址，通常用來存放從某個函式呼叫返回的地址。

## 6.`msr psp, r0`
- 在 ARM 架構中，堆疊指標指向當前的堆疊頂端。ARM 處理器有兩個主要的堆疊指標：

    - MSP（Main Stack Pointer）：用於內核模式，通常用來處理中斷和系統相關的堆疊操作。
    - PSP（Process Stack Pointer）：用於用戶模式，當執行應用程式或用戶任務時使用。
- 在上下文切換時，需要切換到 **PSP** 指向用戶模式的堆疊，這樣可以保持內核和用戶模式堆疊的隔離，避免互相影響。
- `msr指令`（Move to Special Register）：將一般暫存器的內容寫入特定的系統暫存器。在這裡，`msr psp, r0` 將暫存器 `r0` 中的數據寫入 `psp`，設定用戶模式的堆疊指標。

## 7. `mov r0, #3`
- ARM 處理器的 **CONTROL 暫存器** 用來控制處理器的模式、堆疊選擇和特權級別。這個暫存器有一些關鍵位元來決定 CPU 當前的運作狀態，最常用的兩個位元是：

    - Bit 0：決定處理器使用哪個堆疊指標。

        0：使用 MSP（Main Stack Pointer）。

        1：使用 PSP（Process Stack Pointer）。

    - Bit 1：決定處理器是處於特權模式（Privileged Mode）還是非特權模式（Unprivileged Mode）。

        0：特權模式，允許執行所有指令，包括訪問系統控制暫存器。

        1：非特權模式，受限於部分操作，通常用於執行應用程式。

- 將立即數 `3`（即二進位的 `11`） 存入 `r0`，這個值將在下一步設置 **控制暫存器 (CONTROL)** 使用。

## 8. `msr control, r0`
- 將 `r0` 的值寫入 **控制暫存器 (CONTROL)**，這裡的 `#3` 表示：

    - 切換到用戶模式的 PSP 堆疊指標（**使用 PSP**）。
    - 切換到 **非特權模式**，進行應用程式的執行。

## 9. `pop {r4, r5, r6, r7, r8, r9, r10, r11, lr}`
- 恢復先前保存的用戶模式下的暫存器內容，這些可能是用戶模式程序的數據。
- 當 `pop` 指令執行時，處理器會從堆疊中依次取出 `lr`、`r11`、`r10`，一直到 `r4` 的內容，並將這些值寫回相應的暫存器。堆疊指標會自動更新，以反映出堆疊中的數據已被取出。

## 10. `bx lr`
- `bx`（Branch and Exchange）是一條分支指令，用於改變程式的執行流向。它將控制權轉移到鏈接暫存器（LR）中存儲的地址。
- LR（Link Register，通常是 `r14`）儲存當前函式的返回地址。在函式調用時，系統會將返回地址存入 `lr`，以便函式執行完畢後能夠正確返回。
- 這行的目的是：
    - 將控制權轉移到 `lr` 中存儲的地址。
    - 根據 `lr` 最低位元的值（0 或 1）決定使用 ARM 還是 Thumb 指令集。如果最低位元是 0，則使用 ARM 指令集；如果是 1，則使用 Thumb 指令集。

## 總結
這段程式碼的目的是切換系統從內核模式到用戶模式。它首先保存當前的內核狀態，然後切換到用戶模式，最後載入用戶任務的狀態，並跳轉去執行用戶任務。


