# 參考資料
- RTOS基礎知識 : https://www.freertos.org/zh-cn-cmn-s/Documentation/01-FreeRTOS-quick-start/01-Beginners-guide/01-RTOS-fundamentals
- 作業系統 : https://hackmd.io/@Chang-Chia-Chi/OS-CH3

# 堆疊（Stack）
堆疊是一種數據結構，用於管理和儲存程式的執行資訊。它遵循「後進先出」（LIFO，Last In First Out）的原則，也就是最後放入堆疊的數據會最先被取出。可以想像成一堆盤子，最上面的盤子是最容易被取走的。
## 1. 堆疊的主要用途
- 函式呼叫與返回：當一個函式被呼叫時，堆疊會保存當前程式的執行位置（返回地址），以便函式執行完畢後能夠返回。
- 局部變數儲存：函式中的局部變數會被存放在堆疊，當函式結束時，這些變數會被自動釋放。
- 上下文切換：在多任務系統中，堆疊用來保存每個任務的執行狀態，以便在切換到另一個任務時能夠恢復之前的狀態。
## 2. 堆疊操作
- Push（推入）：將數據放入堆疊頂部，並更新堆疊指標。
- Pop（彈出）：從堆疊頂部取出數據並返回給使用者，並更新堆疊指標。
## 3. 堆疊在作業系統中的角色
- 函式執行與任務切換：每當一個任務被啟動或一個函式被呼叫，系統會分配一個堆疊來儲存當前執行狀態，包括返回地址、局部變數等。
- 上下文切換：作業系統會保存當前任務的堆疊狀態，切換到其他任務後再恢復之前的堆疊狀態，以確保程式正確執行。

# 暫存器（Registers）
暫存器是處理器內部的高速儲存空間，負責保存運算過程中的臨時數據。存取速度極快，但數量有限。
## 1. 暫存器的作用
- 存放運算數據：處理器會將當前運算或操作所需的數據暫時存放在暫存器中。
- 處理器控制：某些暫存器負責控制程式執行，例如堆疊指標暫存器（SP, Stack Pointer）。

在 ARM 架構中，常見的暫存器包括 x0 到 x31，例如 x1 會用來存放函式的參數。

## 2. 暫存器與堆疊的關係
由於暫存器數量有限，當函式嵌套或遞迴呼叫時，處理器會將暫存器中的資料保存到堆疊中，以確保之後能夠正確恢復。堆疊的存在允許處理器在運行複雜的程式時，靈活地管理數據和函式狀態。

### 範例：Fib 函式的遞迴呼叫
```c
int fib(int n) {
    return n < 2 ? 1 : fib(n-1) + fib(n-2);
}

int main() {
    printf("%d\n", fib(3));
}
```
### Fib 遞迴的執行流程
當呼叫 `fib(3)` 時：
### 1. 將變數 `3` 存到暫存器：
- `3` 會先被存到暫存器中（例如 x1 暫存器）。
### 2. 遞迴呼叫 `fib(3-1)` 和 `fib(3-2)`：
- 處理器接著執行遞迴呼叫，先進入 `fib(2)`，然後是 `fib(1)`。
### 3. 堆疊保存：
- 當函式進行遞迴呼叫時，原本存放在 x1 暫存器中的值（即 `3`）會被暫時保存到堆疊中，等到需要恢復 `fib(3)` 時，會從堆疊中取回該數值。

# 堆疊指標（Stack Pointer, SP）
堆疊指標是用來指示堆疊區域頂部的記憶體地址。當一個函式被呼叫時，堆疊指標會指向堆疊的最上方，並在函式的執行過程中隨著局部變數和其他資料的推入或推出而改變。

## 堆疊的工作原理
### 1. 堆疊的分配： 
在嵌入式系統中，堆疊通常是從一個高位地址開始，向下增長。例如，假設堆疊的起始地址是 `0x1000`，這意味著堆疊的最上方在 `0x1000`。
### 2. 推入資料： 
當你呼叫一個函式時，該函式的返回地址、參數和局部變數會被推入堆疊。這時，堆疊指標會向下移動。例如，假設我們推入了一個 4 字節的整數，那麼堆疊指標會更新為 `0x0FFC`：
- 初始堆疊指標：`0x1000`
- 推入 4 字節後：`0x1000 - 0x0004 = 0x0FFC`
### 3. 推出資料： 
當函式執行結束並返回時，堆疊指標會更新回去，釋放已推入的資料。例如，如果函式結束後，堆疊指標將再次更新為 `0x1000`。

## 數值的來源
- 堆疊大小： 堆疊的大小通常由微控制器的內部設置決定。對於 STM32 這樣的微控制器，開發者可以在專案設置中指定堆疊的大小，這會影響堆疊的起始地址。
- 堆疊指標的初始值： 堆疊指標的初始值是在程式啟動時由啟動程式設定的，通常會設定為堆疊的起始地址。

## 範例：Fib 函式遞迴中的堆疊操作
以 `fib(3)` 的遞迴呼叫為例：
### 1. 儲存 x1 暫存器中的值：
- 呼叫 `fib(3)` 時，值 `3` 會先存入暫存器 x1。
### 2. 進入 `fib(2)` 的遞迴：
- 因為接下來要處理遞迴呼叫，處理器會將 x1 中的值（即 3）保存到堆疊記憶體位置（例如 0x1000）。
### 3. 更新堆疊指標：
- 堆疊指標 SP 會從 0x1000 向下移動，更新為 0x0ffc，為下一個可能存入的數據預留空間。

# 堆疊範例：任務初始化與切換
```c
void usertask(void)
{
	usart_printf("User Task #1\r\n");
	while (1); /* Never terminate the task */
}

int main(void)
{	
    /* 初始化任務的堆疊 (stack)
	 * r4, r5, r6, r7, r8, r9, r10, r11, lr */
	unsigned int usertask_stack[256];
	unsigned int *usertask_stack_start = usertask_stack + 256 - 16;
	usertask_stack_start[8] = (unsigned int) &usertask;

    /* 初始化 USART 並顯示訊息 */
	usart_init();
	usart_printf("OS Starting...\r\n");

    /* 啟動 usertask 任務 */
	activate(usertask_stack_start);

	while(1){
		/* 主程式無限迴圈，保持系統運行 */
	}

	for(;;);
}
```
## 1. `usertask(void)` 函數
- 使用 `usart_printf` 打印出 `"User Task #1"`，用於顯示任務的執行狀況。
- 進入一個無限迴圈 `while(1)`;，確保任務不會終止，保持持續運行。

## 2. `main` 函數
### 2.1 初始化任務堆疊
- 分配堆疊空間：`unsigned int usertask_stack[256];`創建了 256 個單位的陣列作為該任務的堆疊空間。
- 設置堆疊指標：`usertask_stack_start = usertask_stack + 256 - 16;`堆疊從高位址向低位址生長，指標設置到陣列尾端，並預留 16 個位置，用來存放處理器的暫存器值（`r4` 到 `r11` 等暫存器）。
- 設置函式起點：`usertask_stack_start[8] = (unsigned int) &usertask;` 這行程式碼設置堆疊中的第 8 個位置為 `usertask` 函數的位址，這樣啟動任務時處理器會從該函式開始執行。
### 2.2 初始化 USART 並顯示訊息
- 初始化 USART：`usart_init();`設置串列通訊。
- 顯示系統啟動訊息：`usart_printf("OS Starting...\r\n");`告知系統已經開始運行，顯示訊息 `"OS Starting..."`。
### 2.3 啟動任務
- 啟動新任務：`activate(usertask_stack_start);` 開始執行 `usertask` 任務。

## 3. 程式運行流程總結
### 1. 初始化任務堆疊：
為任務分配堆疊空間，準備好存放暫存器值，並設置任務的執行起點。
### 2. 初始化 USART 並顯示訊息：
通過串列通訊 (USART) 顯示系統啟動訊息 `"OS Starting..."`，通常這個步驟是用來在系統啟動時進行除錯或提示。
### 3. 啟動任務：
透過 `activate` 函數啟動 `usertask` 任務，該任務會打印 `"User Task #1"`，然後進入無限迴圈，持續運行，不會結束。
### 4. 主程式不會進入自身迴圈：
由於 `usertask` 任務的無限迴圈將持續佔用執行權，因此程式不會再返回 `main` 函數，也不會執行 `main` 函數中的無限迴圈。

# 上下文切換（Context Switch）
## 定義
上下文切換是當 CPU 在不同進程之間切換執行時所需的過程。由於 CPU 一次只能執行一個進程，當需要將控制權轉移給另一個進程時，必須保存當前進程的狀態，並載入新進程的狀態。這一過程對於操作系統來說非常重要，因為它能讓多個進程共享 CPU 資源。

## 流程
### 1. 執行 P0
CPU 開始執行第一個進程 P0，該進程正在進行其任務。
### 2. P0 被打斷
- 當時間片到達（即 P0 的執行時間用完）或出現外部中斷（如用戶輸入），P0 可能會被暫停。
- CPU 會進入閒置（idle）狀態，等待進一步指令。
### 3. 進行上下文切換
- 保存當前狀態：系統將 P0 的狀態保存到進程控制塊（PCB）中。PCB 包含了進程的所有信息，包括暫存器值、進程狀態、優先級等。
- 讀取新進程狀態：系統讀取 P1 的 PCB，以獲取它的狀態信息，了解 P1 暫停時的執行狀況。
- 完成上下文切換：CPU 載入 P1 的狀態，恢復 P1 的暫存器值及其他必要的信息。
### 4. 執行 P1
CPU 開始執行新進程 P1，接著 P1 會在它之前被暫停的地方繼續執行。

## 上下文切換的開銷
在整個上下文切換的過程中，CPU 並沒有實際執行任何業務邏輯的指令，因此這段時間被視為開銷（overhead），會浪費一些 CPU 資源。儘管如此，為了實現 CPU 共享和時間共享，上下文切換是不可避免的。

## 優化上下文切換的方式
為了減少上下文切換的開銷，可以採取以下方法：
- 提高內存速度：使用更快的記憶體技術，減少數據存取延遲，讓進程更快讀取或寫入所需數據。
- 減少寄存器數量：設計上可以減少使用的寄存器數量，以降低上下文切換時的存取次數。
- 合併加載與保存 PCB 的指令：透過將多個指令合併為一個操作，減少指令執行次數，提高效率。
- 硬體支援：使用多組寄存器來快速切換不同進程的狀態，減少頻繁訪問內存的需求。

## 總結
上下文切換是操作系統的核心功能之一，使 CPU 能夠在多個進程之間有效切換。透過合理設計和優化，可以減少上下文切換的開銷，提高系統性能。理解上下文切換的過程及其重要性，有助於初學者更好地掌握操作系統的運作原理。

# Context Switch範例
**範例程式**：https://github.com/jserv/mini-arm-os/tree/master/02-ContextSwitch-1

這段 ARM 彙編語言的程式碼，實現了一個名為 `activate` 的函式，目的是切換執行環境，將系統狀態從內核模式切換到用戶模式：
```asm
.thumb
.syntax unified

.global activate
activate:
	/* save kernel state */
	mrs ip, psr
	push {r4, r5, r6, r7, r8, r9, r10, r11, ip, lr}

	/* switch to process stack */
	msr psp, r0
	mov r0, #3
	msr control, r0

	/* load user state */
	pop {r4, r5, r6, r7, r8, r9, r10, r11, lr}

	/* jump to user task */
	bx lr
```
## 1. `.thumb` 和 `.syntax unified`
- 傳統 ARM 指令集中的每個指令都是 32 位元，而 Thumb 指令集中的指令則是 16 位元的，這使得程式碼更緊湊，能夠在有限的記憶體中儲存更多的指令。
- `.thumb` 指定程式碼將以 ARM 的 Thumb 指令集運行，這是一種較精簡的指令集。

    一般來說，標準 ARM 編譯器（如 `arm-none-eabi-gcc`）都自帶對 Thumb 指令集的支援，所以在編譯和鏈接的時候不需要額外包含特定的庫。只要你的編譯器支持 ARM 的 Thumb 指令集，就可以直接使用。
- `.syntax unified` 表示使用統一的彙編語法，允許 ARM 和 Thumb 指令混合使用。

## 2. `.global activate`
- 宣告 `activate` 函式為全域，讓其他文件或程式碼能引用它。

## 3. `activate:`
- 這行代表一個標籤，定義了函式的入口點，使其他程式能跳轉或呼叫此函式。

## 4. `mrs ip, psr`
- `ip`：表示 **"Intra-Procedure-call Scratch Register"**，即 **r12 暫存器**，它是一個可以在函式內部臨時使用的暫存器。
- `mrs` 指令用來從特定的暫存器中讀取數據。這裡是將 **程序狀態暫存器 (PSR)** 的內容存入暫存器 `ip`（即 r12）中，這是為了保存當前的 CPU 狀態，以便後續可能需要恢復這些資訊。PSR 儲存著 CPU 當前的狀態，如旗標 (flags) 和模式資訊。

## 5. `push {r4, r5, r6, r7, r8, r9, r10, r11, ip, lr}`
- `push` **指令** 的作用就是將指定暫存器的內容「推入堆疊」，這意味著把暫存器中當前的數據保存起來，以便稍後可以從堆疊中取回（恢復）；換句話說，**push** 就是為了「暫時保存」，稍後用 **pop** 來「恢復」這些內容，確保切換時不會丟失重要數據。
- 這行的目的是在進行**上下文切換 (context switch)** 時，先保存當前程式的狀態，這樣等到回到這個程式時，能恢復到當前狀態繼續執行。

- r4 到 r11：這些是 ARM 處理器中的通用暫存器，可能儲存了執行中的任務或計算的數據。
- `ip` (r12)：是個臨時暫存器，用來存儲 psr 的內容（當前 CPU 狀態）。
- `lr` (link register)：儲存的是返回地址，通常用來存放從某個函式呼叫返回的地址。

## 6.`msr psp, r0`
- 在 ARM 架構中，堆疊指標指向當前的堆疊頂端。ARM 處理器有兩個主要的堆疊指標：

    - MSP（Main Stack Pointer）：用於內核模式，通常用來處理中斷和系統相關的堆疊操作。
    - PSP（Process Stack Pointer）：用於用戶模式，當執行應用程式或用戶任務時使用。
- 在上下文切換時，需要切換到 **PSP** 指向用戶模式的堆疊，這樣可以保持內核和用戶模式堆疊的隔離，避免互相影響。
- `msr指令`（Move to Special Register）：將一般暫存器的內容寫入特定的系統暫存器。在這裡，`msr psp, r0` 將暫存器 `r0` 中的數據寫入 `psp`，設定用戶模式的堆疊指標。

## 7. `mov r0, #3`
- ARM 處理器的 **CONTROL 暫存器** 用來控制處理器的模式、堆疊選擇和特權級別。這個暫存器有一些關鍵位元來決定 CPU 當前的運作狀態，最常用的兩個位元是：

    - Bit 0：決定處理器使用哪個堆疊指標。

        0：使用 MSP（Main Stack Pointer）。

        1：使用 PSP（Process Stack Pointer）。

    - Bit 1：決定處理器是處於特權模式（Privileged Mode）還是非特權模式（Unprivileged Mode）。

        0：特權模式，允許執行所有指令，包括訪問系統控制暫存器。

        1：非特權模式，受限於部分操作，通常用於執行應用程式。

- 將立即數 `3`（即二進位的 `11`） 存入 `r0`，這個值將在下一步設置 **控制暫存器 (CONTROL)** 使用。

## 8. `msr control, r0`
- 將 `r0` 的值寫入 **控制暫存器 (CONTROL)**，這裡的 `#3` 表示：

    - 切換到用戶模式的 PSP 堆疊指標（**使用 PSP**）。
    - 切換到 **非特權模式**，進行應用程式的執行。

## 9. `pop {r4, r5, r6, r7, r8, r9, r10, r11, lr}`
- 恢復先前保存的用戶模式下的暫存器內容，這些可能是用戶模式程序的數據。
- 當 `pop` 指令執行時，處理器會從堆疊中依次取出 `lr`、`r11`、`r10`，一直到 `r4` 的內容，並將這些值寫回相應的暫存器。堆疊指標會自動更新，以反映出堆疊中的數據已被取出。

## 10. `bx lr`
- `bx`（Branch and Exchange）是一條分支指令，用於改變程式的執行流向。它將控制權轉移到鏈接暫存器（LR）中存儲的地址。
- LR（Link Register，通常是 `r14`）儲存當前函式的返回地址。在函式調用時，系統會將返回地址存入 `lr`，以便函式執行完畢後能夠正確返回。
- 這行的目的是：
    - 將控制權轉移到 `lr` 中存儲的地址。
    - 根據 `lr` 最低位元的值（0 或 1）決定使用 ARM 還是 Thumb 指令集。如果最低位元是 0，則使用 ARM 指令集；如果是 1，則使用 Thumb 指令集。

## 總結
這段程式碼的目的是切換系統從內核模式到用戶模式。它首先保存當前的內核狀態，然後切換到用戶模式，最後載入用戶任務的狀態，並跳轉去執行用戶任務。