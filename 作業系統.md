# 參考資料
- RTOS基礎知識 : https://www.freertos.org/zh-cn-cmn-s/Documentation/01-FreeRTOS-quick-start/01-Beginners-guide/01-RTOS-fundamentals
- 作業系統 : https://hackmd.io/@Chang-Chia-Chi/OS-CH3

# 堆疊（Stack）
堆疊是一種數據結構，用於管理和儲存程式的執行資訊。它遵循「後進先出」（LIFO，Last In First Out）的原則，也就是最後放入堆疊的數據會最先被取出。可以想像成一堆盤子，最上面的盤子是最容易被取走的。
## 1. 堆疊的主要用途
- 函式呼叫與返回：當一個函式被呼叫時，堆疊會儲存當前執行位置的返回地址，這樣函式執行完後，程式可以回到正確的位置繼續執行。
- 局部變數儲存：在函式中定義的變數會被存放在堆疊上，當函式結束時，這些變數會被自動釋放。
- 上下文切換：在多任務系統中，堆疊用來保存每個任務的執行狀態，以便在切換到另一個任務時能夠恢復之前的狀態。
## 2. 如何操作堆疊？
- Push（推入）：將數據放入堆疊。這會將數據放在堆疊的頂部，並更新堆疊指標。
- Pop（彈出）：從堆疊中取出數據。這會移除堆疊頂部的數據並返回給使用者，同時更新堆疊指標。
## 3. 堆疊在作業系統中的角色
在作業系統中，堆疊的運作對程式執行至關重要：
- 每當一個任務被啟動或一個函式被呼叫，系統會分配一個堆疊用來儲存執行狀態。
- 在上下文切換時，作業系統會保存當前任務的堆疊狀態，然後加載新的任務的堆疊狀態，這樣可以確保任務之間的隔離與正確執行。
## 4. 小結
堆疊是程式執行中不可或缺的一部分，負責管理函式呼叫、局部變數以及任務切換的狀態。理解堆疊的概念對於學習作業系統和程式設計都有很大幫助。

# 上下文切換（Context Switch）
## 定義
上下文切換是當 CPU 在不同進程之間切換執行時所需的過程。由於 CPU 一次只能執行一個進程，當需要將控制權轉移給另一個進程時，必須保存當前進程的狀態，並載入新進程的狀態。這一過程對於操作系統來說非常重要，因為它能讓多個進程共享 CPU 資源。

## 流程
### 1. 執行 P0
CPU 開始執行第一個進程 P0，該進程正在進行其任務。
### 2. P0 被打斷
- 當時間片到達（即 P0 的執行時間用完）或出現外部中斷（如用戶輸入），P0 可能會被暫停。
- CPU 會進入閒置（idle）狀態，等待進一步指令。
### 3. 進行上下文切換
- 保存當前狀態：系統將 P0 的狀態保存到進程控制塊（PCB）中。PCB 包含了進程的所有信息，包括暫存器值、進程狀態、優先級等。
- 讀取新進程狀態：系統讀取 P1 的 PCB，以獲取它的狀態信息，了解 P1 暫停時的執行狀況。
- 完成上下文切換：CPU 載入 P1 的狀態，恢復 P1 的暫存器值及其他必要的信息。
### 4. 執行 P1
CPU 開始執行新進程 P1，接著 P1 會在它之前被暫停的地方繼續執行。

## 上下文切換的開銷
在整個上下文切換的過程中，CPU 並沒有實際執行任何業務邏輯的指令，因此這段時間被視為開銷（overhead），會浪費一些 CPU 資源。儘管如此，為了實現 CPU 共享和時間共享，上下文切換是不可避免的。

## 優化上下文切換的方式
為了減少上下文切換的開銷，可以採取以下方法：
- 提高內存速度：使用更快的記憶體技術，減少數據存取延遲，讓進程更快讀取或寫入所需數據。
- 減少寄存器數量：設計上可以減少使用的寄存器數量，以降低上下文切換時的存取次數。
- 合併加載與保存 PCB 的指令：透過將多個指令合併為一個操作，減少指令執行次數，提高效率。
- 硬體支援：使用多組寄存器來快速切換不同進程的狀態，減少頻繁訪問內存的需求。

## 總結
上下文切換是操作系統的核心功能之一，使 CPU 能夠在多個進程之間有效切換。透過合理設計和優化，可以減少上下文切換的開銷，提高系統性能。理解上下文切換的過程及其重要性，有助於初學者更好地掌握操作系統的運作原理。

# Context Switch範例
**範例程式**：https://github.com/jserv/mini-arm-os/tree/master/02-ContextSwitch-1

這段 ARM 彙編語言的程式碼，實現了一個名為 `activate` 的函式，目的是切換執行環境，將系統狀態從內核模式切換到用戶模式：
```asm
.thumb
.syntax unified

.global activate
activate:
	/* save kernel state */
	mrs ip, psr
	push {r4, r5, r6, r7, r8, r9, r10, r11, ip, lr}

	/* switch to process stack */
	msr psp, r0
	mov r0, #3
	msr control, r0

	/* load user state */
	pop {r4, r5, r6, r7, r8, r9, r10, r11, lr}

	/* jump to user task */
	bx lr
```
## 1. `.thumb` 和 `.syntax unified`
- 傳統 ARM 指令集中的每個指令都是 32 位元，而 Thumb 指令集中的指令則是 16 位元的，這使得程式碼更緊湊，能夠在有限的記憶體中儲存更多的指令。
- `.thumb` 指定程式碼將以 ARM 的 Thumb 指令集運行，這是一種較精簡的指令集。

    一般來說，標準 ARM 編譯器（如 `arm-none-eabi-gcc`）都自帶對 Thumb 指令集的支援，所以在編譯和鏈接的時候不需要額外包含特定的庫。只要你的編譯器支持 ARM 的 Thumb 指令集，就可以直接使用。
- `.syntax unified` 表示使用統一的彙編語法，允許 ARM 和 Thumb 指令混合使用。

## 2. `.global activate`
- 宣告 `activate` 函式為全域，讓其他文件或程式碼能引用它。

## 3. `activate:`
- 這行代表一個標籤，定義了函式的入口點，使其他程式能跳轉或呼叫此函式。

## 4. `mrs ip, psr`
- `ip`：表示 **"Intra-Procedure-call Scratch Register"**，即 **r12 暫存器**，它是一個可以在函式內部臨時使用的暫存器。
- `mrs` 指令用來從特定的暫存器中讀取數據。這裡是將 **程序狀態暫存器 (PSR)** 的內容存入暫存器 `ip`（即 r12）中，這是為了保存當前的 CPU 狀態，以便後續可能需要恢復這些資訊。PSR 儲存著 CPU 當前的狀態，如旗標 (flags) 和模式資訊。

## 5. `push {r4, r5, r6, r7, r8, r9, r10, r11, ip, lr}`
- `push` **指令** 的作用就是將指定暫存器的內容「推入堆疊」，這意味著把暫存器中當前的數據保存起來，以便稍後可以從堆疊中取回（恢復）；換句話說，**push** 就是為了「暫時保存」，稍後用 **pop** 來「恢復」這些內容，確保切換時不會丟失重要數據。
- 這行的目的是在進行**上下文切換 (context switch)** 時，先保存當前程式的狀態，這樣等到回到這個程式時，能恢復到當前狀態繼續執行。

- r4 到 r11：這些是 ARM 處理器中的通用暫存器，可能儲存了執行中的任務或計算的數據。
- `ip` (r12)：是個臨時暫存器，用來存儲 psr 的內容（當前 CPU 狀態）。
- `lr` (link register)：儲存的是返回地址，通常用來存放從某個函式呼叫返回的地址。

## 6.`msr psp, r0`
- 在 ARM 架構中，堆疊指標指向當前的堆疊頂端。ARM 處理器有兩個主要的堆疊指標：

    - MSP（Main Stack Pointer）：用於內核模式，通常用來處理中斷和系統相關的堆疊操作。
    - PSP（Process Stack Pointer）：用於用戶模式，當執行應用程式或用戶任務時使用。
- 在上下文切換時，需要切換到 **PSP** 指向用戶模式的堆疊，這樣可以保持內核和用戶模式堆疊的隔離，避免互相影響。
- `msr指令`（Move to Special Register）：將一般暫存器的內容寫入特定的系統暫存器。在這裡，`msr psp, r0` 將暫存器 `r0` 中的數據寫入 `psp`，設定用戶模式的堆疊指標。

## 7. `mov r0, #3`
- ARM 處理器的 **CONTROL 暫存器** 用來控制處理器的模式、堆疊選擇和特權級別。這個暫存器有一些關鍵位元來決定 CPU 當前的運作狀態，最常用的兩個位元是：

    - Bit 0：決定處理器使用哪個堆疊指標。

        0：使用 MSP（Main Stack Pointer）。

        1：使用 PSP（Process Stack Pointer）。

    - Bit 1：決定處理器是處於特權模式（Privileged Mode）還是非特權模式（Unprivileged Mode）。

        0：特權模式，允許執行所有指令，包括訪問系統控制暫存器。

        1：非特權模式，受限於部分操作，通常用於執行應用程式。

- 將立即數 `3`（即二進位的 `11`） 存入 `r0`，這個值將在下一步設置 **控制暫存器 (CONTROL)** 使用。

## 8. `msr control, r0`
- 將 `r0` 的值寫入 **控制暫存器 (CONTROL)**，這裡的 `#3` 表示：

    - 切換到用戶模式的 PSP 堆疊指標（**使用 PSP**）。
    - 切換到 **非特權模式**，進行應用程式的執行。

## 9. `pop {r4, r5, r6, r7, r8, r9, r10, r11, lr}`
- 恢復先前保存的用戶模式下的暫存器內容，這些可能是用戶模式程序的數據。
- 當 `pop` 指令執行時，處理器會從堆疊中依次取出 `lr`、`r11`、`r10`，一直到 `r4` 的內容，並將這些值寫回相應的暫存器。堆疊指標會自動更新，以反映出堆疊中的數據已被取出。

## 10. `bx lr`
- `bx`（Branch and Exchange）是一條分支指令，用於改變程式的執行流向。它將控制權轉移到鏈接暫存器（LR）中存儲的地址。
- LR（Link Register，通常是 `r14`）儲存當前函式的返回地址。在函式調用時，系統會將返回地址存入 `lr`，以便函式執行完畢後能夠正確返回。
- 這行的目的是：
    - 將控制權轉移到 `lr` 中存儲的地址。
    - 根據 `lr` 最低位元的值（0 或 1）決定使用 ARM 還是 Thumb 指令集。如果最低位元是 0，則使用 ARM 指令集；如果是 1，則使用 Thumb 指令集。

## 總結
這段程式碼的目的是切換系統從內核模式到用戶模式。它首先保存當前的內核狀態，然後切換到用戶模式，最後載入用戶任務的狀態，並跳轉去執行用戶任務。