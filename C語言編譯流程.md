# C語言編譯流程
C 語言的編譯過程可以大致分為四個主要步驟：

**1. 預處理 (Pre-processing)**

在這個階段，編譯器會展開宏（macro）定義、處理條件編譯指令（如 `#ifdef`、`#include` 等）、刪除註解，並生成預處理過的代碼。這一階段的輸出是 `.i` 檔案。

**2. 編譯 (Compilation)**

編譯器將預處理後的程式碼轉換成組合語言。這一階段包括詞法分析、語法分析、語意分析、原始碼最佳化以及程式碼生成。最終生成的文件是 `.s` 檔案（組合語言源碼）或直接生成 `.o` 檔案（目標文件），視編譯器設置而定。

**3. 組譯 (Assembly)**

組譯器將組合語言源碼（.s 檔案）轉換成機器碼。這一階段的輸出是 `.o` 或 `.obj` 檔案，這些檔案包含了可被處理器理解的機器指令。

**4. 連結 (Linking)**

連結器將目標文件（`.o` 檔案）與其他需要的庫文件鏈接在一起，生成最終的可執行檔案。這一階段處理所有符號的解析和重定位，生成完整的可執行檔案（如 `.exe` 或無副檔名的可執行文件）。

### 參考連結
- <https://chivincent.gitbooks.io/c-tutorial/content/chapter2/compile.html>
- <https://medium.com/@alastor0325/https-medium-com-alastor0325-compilation-to-linking-c07121e2803>


## 預處理 (pre-processing)
在編譯的第一階段，**預處理器**主要負責對原始碼進行一系列操作，以確保後續的編譯能順利進行。這個階段處理的內容主要包括宏（macro）、條件式編譯、以及外部文件的展開。

### 主要步驟：
1. 展開marco與刪除 `#define`：
    - 預處理器會將所有的宏定義（macro）替換為對應的值。例如：
        ```cpp
        #define PI 3.14
        ```
        會將程式中所有的 `PI` 替換為 `3.14`，然後刪除這個 `#define`。
2. 處理預編譯條件：

    - 預處理器會根據條件來決定哪些部分的程式碼應該被保留，哪些應該被忽略。例如，以下程式碼只在定義了 `DEBUG` 時才會包含：
        ```cpp
        #ifdef DEBUG
        std::cout << "Debug mode" << std::endl;
        #endif
3. 展開 `#include`：
    - 預處理器會展開所有的 `#include`，將外部引用的頭文件內容插入到當前文件中。例如，標準庫的 `<iostream>` 在預處理後會被展開為具體的代碼。
4. 刪除註解：
    - 預處理器會移除程式碼中的所有註解，因為它們不會被編譯器解讀。這包括單行註解（`//`）和多行註解（`/* ... */`）。
5. 增加行號與文件識別名：
    - 預處理器會增加行號和文件名的標識，這樣在後續編譯過程中如果出現錯誤，編譯器能精確地指出錯誤發生的位置。

### 預處理輸出文件 (.i 檔案)
使用以下指令可以生成預處理後的 `.i` 檔案：
```bash
g++ -E main.cpp -o main.i
```
`.i` 文件是經過預處理的結果，會展開所有宏和頭文件，並且刪除註解。實際的 `.i` 文件可能會非常大，特別是如果你使用了像 `iostream` 這樣的標準庫，它可能包含大量的函數和模板定義。

### 結論
預處理是編譯流程中的第一步，主要負責展開宏、處理條件式編譯、展開 `#include`，並刪除註解。這一步驟確保了編譯器在處理源碼時，已經得到了整合且簡化的程式碼。

## 編譯 (compilation)
編譯是將原始碼轉換成機器可以理解的指令的過程，此階段編譯器會將展開後的程式碼轉換成組合語言。編譯過程可以細分為多個步驟，分別是：

1. 詞法分析 (Lexical Analysis)或稱為掃描 (Scanning)：將原始代碼轉換成一系列的「詞」(tokens)。
2. 語法剖析 (Syntax Analysis)或稱為語法分析 (Parsing)：檢查程式碼是否符合語言的語法規則，並構建語法樹(Syntax Tree)。
3. 語意分析 (Semantic Analysis)：檢查語法樹中的語意規則是否正確，例如類型檢查、變量的作用域等。
4. 原始碼最佳化 (Source Code Optimization)：在轉換為組合語言前，對程式碼進行最佳化，減少不必要的計算或操作。
5. 程式碼生成與最佳化 (Code Generation and Optimization)：將程式碼轉換為組合語言或機器碼，並進行底層最佳化。
----
### 詞法分析 (Lexical Analysis)
詞法分析的主要工作是將原始碼轉換為基本的構建單元，稱為 token。每個 token 代表程式中的一個詞彙單位，例如關鍵字、變量名、數值、運算符等。這些 token 將在後續步驟中組合成語法結構。

**Token 範例**

例如對以下程式碼 a = 3 + 5;，會解析成以下 token：
- a：變數名（標識符，identifier）
- =：賦值運算符
- 3 和 5：常數
- +：運算符
- ;：分號（語句結束符）
---
### 語法剖析 (Syntax Analysis)
語法剖析的主要工作是將這些 token 組織成一個結構化的 **語法樹(syntax tree)**，並檢查程式碼的語法是否正確。這個階段會確保運算式的結構、括號的匹配、語句的順序等語法規則都被滿足。

**語法樹的作用：**
1. 幫助分析：語法樹能幫助我們分析複雜的運算式或語句結構是否符合語言的語法規則。
2. 後續處理：語法樹可以作為後續步驟(如語意分析、最佳化、生成中間代碼)的基礎。

**語法樹範例**

對於 `a = 3 + 5`;，語法樹會顯示變數 `a` 在等式左側，並將加法運算組織成一個子樹，表示 `3 + 5` 的運算結果賦值給 `a`。

![alt text](./note%20image/syntax%20tree.png)
---
### 語意分析 (Semantic Analysis)
語意分析是檢查語法樹的語意是否正確。例如，確保變數在使用前被正確初始化，函數呼叫時的參數數量和類型是否匹配。

**語意分析內容**
1. 靜態語意分析：
- 定義：在編譯期間進行的，編譯器會檢查代碼中的語意錯誤。
- 例子：型態檢查（例如，確保你不會將整數和字符串進行相加）、變量的使用前初始化、函數調用時的參數匹配等。
- 檢查項目：型態兼容性、變量的作用域、函數的定義和調用是否匹配等。
2. 動態語意分析：
- 定義：在程式執行期間進行，這些錯誤通常無法在編譯期間檢測到。
- 例子：除數為零的錯誤、數組越界、空指針解引用等。
- 檢查項目：程式運行時的錯誤，這些錯誤只有在程式運行時才會顯現出來。

經過分析後，我們可以在文法樹上加上語意型別。

![alt text](./note%20image/commented%20syntax%20tree.png)
---
### 原始碼最佳化 (Source Code Optimization)
在語法樹生成後，編譯器可以對程式碼進行一些最佳化。
現代編譯器通常會有不同層級的最佳化方式，這裡提到的是原始碼層級的最佳化。
例如，對於簡單的運算式 `3 + 5`，可以直接將其結果 `8` 替換，省去不必要的計算。

此外，為了提高程式碼轉換為組合語言的效率，編譯器也會將程式碼轉換為一種 三位址碼 (Three Address Code) 的形式，將複雜的運算分解為更簡單的指令。

三位址碼的基本形式如下，`x = y op z`，在等號的右側至多只能有一個操作符號(operator)，例如：
```cpp
a = 4 * 5 + 3;
```
可以分解為以下三位址碼：
```cpp
t1 = 4 * 5
t2 = t1 + 3 
a = t2
```
---
### 程式碼生成與最佳化 (Code Generation and Optimization)
程式碼生成是編譯過程中的最後階段，編譯器會將中間代碼（如三位址碼）轉換為目標機器的組合語言或機器碼。同時，編譯器會對生成的程式碼進行最佳化，確保其執行效率達到最大化。這一階段可以分為兩部分：**程式碼生成**和**程式碼最佳化**。

**1. 程式碼生成**

這是將中間代碼轉換為組合語言或機器碼的過程。編譯器根據目標機器的特性來選擇合適的指令。

**2. 程式碼最佳化**

程式碼生成後，編譯器會對組合語言或機器碼進行進一步的優化，這些優化技術可以提高執行效率，降低程式的資源消耗。

- 選擇有效的指令：根據硬體架構，選擇執行速度最快的指令。例如，一些乘法操作可以用位移操作來取代。
- 位移操作優化：在某些情況下，乘以2的次方可以用位移操作（如左移）來取代，因為位移操作比乘法執行得更快。例如，乘以4可以轉換為位移2位，這會明顯提高執行效能。

**組合語言範例**

對於 `a = 3 + 5`，可能生成如下的組合語言指令：
```assembly
mov eax, 8               ; 將數字 8 存入暫存器 eax
mov [address_of_a], eax  ; 將 eax 中的值存入變量 a 的地址
```
**優化範例**

如果程式中有 `a = b * 4`，編譯器可能會將這個乘法運算轉換成位移操作，因為位移運算更高效：

```assembly
mov eax, [address_of_b]  ; 將變量 b 的值載入暫存器 eax
shl eax, 2               ; 將 eax 的值左移兩位，相當於乘以 4
mov [address_of_a], eax  ; 將結果存入變量 a
```
---
### 編譯器指令範例
你可以使用以下指令來將 C++ 源文件轉換為組合語言(.cpp -> .s)，編譯器會自動執行所有步驟，包括預處理、編譯：
```bash
g++ -S main.cpp -o main.s
```
如果已經有預處理過的 `.i` 檔，可以跳過預處理階段，直接生成組合語言：
```bash
g++ -S main.i -o main.s
```

## 組譯 (assembly)
組譯是將組合語言轉換成機器碼的過程，組合語言是一種低階語言，其指令與特定的處理器架構相關。組譯器會將這些指令轉換為處理器可以理解的二進位機器碼。

### 組譯步驟
**1. 讀取組合語言源碼**：組譯器讀取由組合語言編寫的源碼。

**2. 解析指令**：將組合語言中的每條指令解析為相應的機器碼指令。

**3. 生成機器碼**：根據指令集架構(ISA)的對照表，將組合語言指令轉換為對應的機器碼。

**4. 生成目標檔案**：將機器碼指令寫入目標檔案（通常是 `.o` 或 `.obj` 檔案）。

編譯時可以使用以下指令生成 .o 檔案：
```bash
g++ -c main.cpp -o main.o
```
### 組譯詳解
**- 指令集架構 (ISA)**：

每個處理器架構都有一套指令集，組譯器會根據這套指令集將組合語言轉換成對應的機器碼。

**- .s 檔案的角色**：

在編譯過程中，並不一定需要先生成 `.s` 檔（組合語言源碼的中間檔案），因為 `.s` 檔通常用於**調試**或**分析**。編譯器可以直接將 `.cpp` 或 `.i` 檔案轉換為 `.o`（目標文件）檔案，而這個過程已經涵蓋了所有編譯步驟。

**通用編譯流程**

描述了從原始程式碼到最終可執行檔案的完整流程。每個階段有其特定的處理目的和生成的檔案。即使某些階段可以被省略（如不生成 `.s` 檔案），整體流程仍然包括這些步驟。

---
### 目標檔案 (Object File)
目標檔案是組譯器生成的中間檔案，儲存的是二進位機器碼，通常遵循可執行文件格式 (ELF)。

#### ELF 格式

ELF（Executable and Linkable Format）是一種用於儲存可執行檔案、目標檔案及共享庫的文件格式，廣泛應用於類 UNIX 系統（如 Linux），ELF 檔案作為可執行檔案或可重定位的物件檔（共享庫等），會在程序載入至記憶體執行時將 .text、.data、.bss 等段映射到記憶體中的對應區域。。

ELF 檔案包含以下主要區段：

**1. 代碼區段 (Text Segment)**：儲存程式的機器碼（可執行指令）。該區段(.text))通常是唯讀的，防止在執行期間被修改。

**2. 數據區段 (Data Segment)**：儲存靜態數據，如全域變數和靜態變數。數據區段分為兩個子區段：

- .data 段：包含已初始化的靜態數據，例如變數已設定為特定值（非 0）。該段在檔案中佔用空間，因為需要儲存這些數據。
- .bss 段：包含未初始化或初始化為 0 的靜態數據。`.bss` 不佔用檔案空間，僅在記憶體中分配空間，並自動初始化為 0。

#### 補充：Heap 和 Stack
Heap 和 Stack 並非 ELF 檔案的一部分，它們是在程式執行時由操作系統動態分配的記憶體區段：

- Heap（堆）：動態記憶體分配區域。程式運行時，通過如 `malloc` 或 `new` 等函數分配記憶體來自該區段。

- Stack（堆疊）：管理函數呼叫和局部變數的區域。隨著函數呼叫和返回，堆疊區段動態增長或縮小。

ELF 檔案定義了程式的靜態區段（如 `.text`、`.data` 和 `.bss`），這些區段在程式載入至 RAM 時，會對應映射到記憶體中的特定區域。而 Heap 和 Stack 雖然也會佔用記憶體空間，但它們由操作系統在程式執行時動態管理，並不屬於 ELF 檔案內的區段。

**3. 符號表 (Symbol Table)**：列出程式中的變數、函數及其位址。符號表主要用於連結和調試過程，一般不包含在最終的可執行檔案中。

**4. 重定位表 (Relocation Table)**：記錄在連結或載入階段需要調整的地址，確保程式碼和數據正確地映射到記憶體中。這在處理動態連結或共享函式庫時尤為重要。

### 區段劃分的好處
將代碼區段與數據區段分開有助於程式運行時的安全性與效能提升，主要好處包括：

**1. 權限控制**：代碼區段可設置為只讀（read-only），數據區段則可設置為讀寫（read-write），提升安全性。

**2. 緩存優化**：分開的區段設計提高了 CPU 緩存的命中率，優化了資源使用。

**3. 共享資源**：多個程序可共享相同的程式區段，減少內存消耗。

## 鏈接 (linking)
在編譯程式的過程中，鏈接(linking)是至關重要的一個步驟。這個過程讓編譯器知道程式中外部函數或變數的具體位址。例如，當我們在main.cpp裡使用func.cpp裡的foo() 函數時，編譯器需要確定foo()函數的位置才能正確呼叫它。

### 符號與符號名
在編譯過程中，每個被定義的變數或函數都會有一個名稱，稱為「符號名」(symbol name)，它代表一個特定的變數或函數的位置或地址。

- 符號 (symbol)：編譯器會將程式中的變數、函數、常量等視為符號。這些符號對應著程式中的具體實體，例如變數的記憶體地址或函數的代碼。
- 符號名 (symbol name)：符號的名稱，例如變數名或函數名。編譯器通過這些名稱來追蹤程式中符號的使用和位置。

在鏈接過程中，會進行符號解析(symbol resolution)，確保每個符號名都能被正確解析，並且對應到程式中的正確位置。

### 鏈接過程可以分為兩種形式：
1. 靜態鏈接 (Static Linking)
    - 概念：在靜態鏈接中，所有被引用的函數和變數都會直接整合到最終的可執行檔案內，無需依賴外部的函式庫。
    - 優點：程式是自包含的。這意味著當程式執行時，它不需要依賴任何外部檔案即可正常運作。
    - 缺點：因為所有引用的代碼都包含在可執行檔內，這會增加可執行檔案的大小。
舉例：
如果我們在main.cpp中呼叫foo()函數，靜態鏈接會將func.cpp裡的foo()函數編譯好的機器碼和main.cpp一起合併，生成最終的可執行檔案。

2. 動態鏈接 (Dynamic Linking)
    - 概念：在動態鏈接中，外部函數或變數的地址並不會在編譯期確定，而是推遲到程式執行時才解析。這通常用於共享庫(如 .so 或 .dll)，這些共享庫會在程式執行時動態載入。
    - 優點：減少了可執行檔案的大小，並允許多個程式共享相同的庫檔案，節省記憶體資源。
    - 缺點：程式執行時需要依賴這些動態庫。如果動態庫遺失或版本不對，程式可能會無法正常執行。
舉例：
在動態鏈接的情況下，鏈接器只會記錄 foo() 函數的符號，實際的地址在程式執行時會從共享庫中動態查找。

### 靜態與動態鏈接的符號處理
1. 靜態鏈接：符號名在鏈接過程中解析。當最終的機器碼生成後，符號名不再需要，因為所有的位址已經被固定。
2. 動態鏈接：符號名會保留到程式執行時，用來從動態庫中解析函數和變數。

### 靜態鏈接 vs 動態鏈接的使用場合
1. 嵌入式系統：在某些嵌入式系統中，或者在需要高可靠性的情境中，靜態鏈接較常見。因為它能保證所有依賴在編譯時已經解決，不需要在執行時依賴其他外部檔案。
2. 共享庫的可用性：動態鏈接更適合在需要節省存儲空間的場景中使用，因為多個程式可以共享相同的函式庫，減少記憶體使用量。

### 總結：鏈接的目的
無論是靜態還是動態鏈接，最終的目的都是讓代碼中的外部函數或變數的位址在最終的可執行檔案中明確化，確保程式能夠正確執行。

### 更深入的細節：符號表與重定位表
在編譯階段，我們可以知道會呼叫哪些符號，但不知道它們的具體位址，因此會賦予這些符號一個暫時的位址，並且記錄在符號表(symbol table)和重定位表(relocation table)中。

鏈接器會根據這些表進行重定位，將暫時的位址替換為最終的實際位址，完成可執行檔案的生成。
